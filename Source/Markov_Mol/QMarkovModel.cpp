#include <fstream>

#include "Markov_Mol/QMarkovModel.h"
#include "Markov_Mol/QAux.h"

#include "Markov_LA/matrixAritmetic.h"
#include "Markov_LA/matrixInit.h"
#include "Markov_LA/matrixSum.h"
#include "Markov_LA/matrixMaxMin.h"
#include "Markov_LA/matrixInverse.h"
#include "Markov_LA/matrixProduct.h"
#include "Markov_LA/matrixExp.h"
#include "Markov_LA/matrixRounding.h"
#include "Markov_LA/matrixOperators.h"

//#include "Markov_LA/auxiliarRelational.h"

#include "Markov_IO/ClassDescription.h"
#include "Markov_IO/auxiliarIO.h"
#include "Tests/AssertPlain.h"


namespace Markov_Mol
{
  
  
  extern "C" void dgeev_(char *jobvl,
                         char *jobvr,
                         int *n,
                         double *a,
                         int *lda,
                         double *wr,
                         double *wi,
                         double *vl,
                         int *ldvl,
                         double *vr,
                         int *ldvr,
                         double *work,
                         int *lwork,
                         int *info);
  
  
  
  
  Q_Markov_Model* Q_Markov_Model::clone() const
  {
    return new Q_Markov_Model(*this);
  };
  Q_Markov_Model* Q_Markov_Model::create() const
  {
    return new Q_Markov_Model();
  };
  
  
  std::string Q_Markov_Model::name()const
  {
    return this->name_;
  }
  
  ///**
  //  Author of the last modification of the model.
  //  The author of the model is defined as either the first author of the
  //  original publication from where the model have been taken verbatim, or
  //  just the operator of the program. If the model is modified somehow (by the
  //  function setParameters the author is then the operator of the program.
  //  @returns a string with the last name of the author of the model
  //  */
  //std::string Q_Markov_Model::author()const{
  //return author_;
  //};
  
  
  ///**
  //  Date of the last modification to the model.
  //  If the model follows exactly a published model, we take the earliest date
  //  of reception of the paper. If the model does not follow strictly the
  //  published model, it returns the earliest date with the same parameters.
  //  If the model is modified, the date is updated.
  //  @returns the date in the format YYYYMMDD
  // */
  //std::string Q_Markov_Model::date()const{
  //return date_;
  //};
  
  
  ///**
  //  Name of the file for saving the model
  //  @returns Author+data+id_number
  //  It forms a string with the Author(),date() and an idnumer()
  //  */
  //std::string Q_Markov_Model::fname()const
  //{
  //    return author_+date_;
  //}
  
  
  
  
  
  
  //const Publication& Q_Markov_Model::pub()const
  //{
  //    return Pub_P;
  //};
  
  /// This function returns the cannonical labels for the different arguments  of the object constructor
  
  
  
  
  
  ///**  Saves the model with an specified format
  //     @param dirName the complete address of the directory where the model is
  //     to be saved. The model name is generated by the function fname.
  //     containing the object is to be written.
  //     @param extension indicates the format of the file
  //     @post the model is written in the file in such a way that it can be
  //     reconstructed, so it can be written
  //	   @verbatim
  //	   // ABC_Markov_Model is abstract, so we need a derived class
  //	   Class_Derived_From_ABC_Markov_Model modelAlreadyThere;
  //	   //save on any place
  //	   std::string fname=model.save("C:\myDir", "xml");
  //	   // it will create a filename based on
  //	   Class_Derived_From_ABC_Markov_Model emptyModel;
  //	   emptyModel.load("C:\myDir\Myself_20110226_1.model.xml");
  //	   assert(emptyModel==model);
  //	   @endverbatim
  //      @returns a string with the name of the file where the model was saved
  //      or an empty string if failed.
  //  */
  //std::string Q_Markov_Model::save(const std::string& dirName,
  //				 const std::string& extension){};
  
  
  
  /*
  Q_Markov_Model::Q_Markov_Model():
    patch_(0),
    name_(),
    k_u(0),
    Q_M(M_Matrix<double>()),
    Q0_M(M_Matrix<double>()),
    Q1_M(M_Matrix<double>()),
    QC_M(M_Matrix<double>()),  // cycles completed
    K_M(M_Matrix<double> ()),// --> indicates the equilibrium function
    conn_Map(std::multimap<std::size_t,std::size_t>()),
    tau_Map(std::map<std::pair<std::size_t,std::size_t> ,double>()), // exchange times
    g_M(M_Matrix<double>()),
    g0_M(M_Matrix<double>()),
    a_M(M_Matrix<size_t>())
  {
  }
  */
  Q_Markov_Model::Q_Markov_Model(const std::string & model_name,
                                 std::size_t n,
                                 ABC_PatchModel * mypatch):
    patch_(mypatch),
    name_(model_name),
    k_u(n),
    Q_M(M_Matrix<double>(n,n)),
    Q0_M(M_Matrix<double>(n,n)),
    Q1_M(M_Matrix<double>(n,n)),
    QC_M(M_Matrix<double>()), //par
    K_M(M_Matrix<double>()), //par
    conn_Map(), //par
    tau_Map(),  // cycles completed

    g_M(M_Matrix<double>(n,1)),
    g0_M(M_Matrix<double>(n,1)),
    gamma_d(0),
    a_M(M_Matrix<size_t>(n,1)),
    parameters_Map()
  {}
  
  
  Q_Markov_Model::~Q_Markov_Model() {}
  
  
  
  const ABC_PatchModel* Q_Markov_Model::patch()const
  {
    return patch_;
  }
  
  void Q_Markov_Model::setPatch(const ABC_PatchModel* newPatch)
  {
    patch_=newPatch;
  }
  
  
  std::size_t Q_Markov_Model::k()const
  {
    return k_u;
  }
  
  const M_Matrix<double>& Q_Markov_Model::Q() const
  {
    return Q_M;
  }
  
  
  const M_Matrix<double>& Q_Markov_Model::Q0() const
  {
    return Q0_M;
  }
  
  
  const M_Matrix<double>& Q_Markov_Model::Q1() const
  {
    return Q1_M;
  }
  
  
  const M_Matrix<size_t>& Q_Markov_Model::n_bound_agonists() const
  {
    return a_M;
  }
  
  
  const M_Matrix<double>& Q_Markov_Model::g() const
  {
    
    return g_M;//*gamma_d;
  }
  
  
  double Q_Markov_Model::gamma() const
  {
    return gamma_d;
  }
  
  
  std::string Q_Markov_Model::kij_Label(std::size_t i,std::size_t j)
  {
    if ((i<k_u)&&(j<k_u))
      {
        std::string kij="k_"+Markov_IO::ToString(i)+
            "_to_"+Markov_IO::ToString(j);
        return kij;
      }
    else
      {
        std::string msg="i or j too big";
        return msg;
      };
  }
  
  
  /// constructor
  Q_Markov_Model::Q_Markov_Model(Markov_IO::ABC_Var* parent,
                                 const std::string& model_name_identifier,
                                 const M_Matrix<double>& Q_matrix,
                                 const M_Matrix<double>& conductance_vector,
                                 const M_Matrix<std::size_t>& agonist_vector,
                                 double unitary_conductance,
                                 ABC_PatchModel* mypatch,
                                 const std::string& tip,
                                 const std::string& whatthis):
    Implements_Class_Reflection<Q_Markov_Model>(
      parent,model_name_identifier,this,ClassName(),tip,whatthis),
    patch_(mypatch),
    name_(model_name_identifier),
    k_u(nrows(Q_matrix)),
    Q_M(Q_matrix),
    Q0_M(M_Matrix<double>(k_u,k_u)),
    Q1_M(M_Matrix<double>(k_u,k_u)),
    QC_M(M_Matrix<double>()), //par
    K_M(M_Matrix<double>()), //par
    conn_Map(), //par
    tau_Map(),  // cycles completed

    g_M(conductance_vector*unitary_conductance),
    g0_M(conductance_vector),
    gamma_d(unitary_conductance),
    a_M(agonist_vector),
    parameters_Map()
  {
    Q_to_conn_K_tau_QC();
    QC_to_Q0_Q1();
    buildParameters();
    initComplexVar();

  }
  
  
  inline
  bool Q_Markov_Model::get_states_from_kij_Label(std::string kij,std::size_t& i,std::size_t& j)
  {
    if (kij.find("k_")!=0) return false;
    std::size_t pos=kij.find("_to_");
    if (pos==std::string::npos) return false;
    std::string s=kij.substr(2,pos-2);
    if (!Markov_IO::ToValue<std::size_t>(s,i))
      return false;
    s=kij.substr(pos+4);
    if (!Markov_IO::ToValue<std::size_t>(s,j))
      return false;
    return true;
  }
  
  inline
  void
  Q_Markov_Model::update()
  {
    Q_to_conn_K_tau_QC();
    QC_to_Q0_Q1();
    Q_dt_buff_avg.reset();
    Q_dt_buff_two_anchor.reset();
    Q_dt_buff_avg_varx.reset();
    Q_dt_buff_not_avg.reset();
    Q_x_buff_avg.reset();
    Q_x_buff_not_avg.reset();
  }

  void Q_Markov_Model::initComplexVar()
  {
    push_backRefMethod(
          "Q_matrix",
          &Q_Markov_Model::Q,
    {},
          "",
          "rate constant matrix in a 1 micromolar solution",
          "Q-matrix is a square matrix of k dimensions, where Q(i,j) represents the"
          "rate constant for going from the state i to the state j in a 1 micromolar"
          "solution of the agonist");
    push_backVarPointer("conductance_vector",
                        &Q_Markov_Model::g0_M,
                        "",
                        "current for each state, a zero value for the closed states, "
                        "one for fully open, between zero and one for partially open states",
                        "a column vector of k elements g(i) representing the single "
                        "channel current for the state i, expressed as the ratio of "
                        "the maximal current generated by any state");
    push_backVarPointer("agonist_vector",
                        &Q_Markov_Model::a_M,
                        "",
                        "number of agonist bound to each state",
                        "this information is used to determine which rate constants are dependent "
                        "upon the agonist concentration");
    push_backVarPointer("unitary_conductance",
                        &Q_Markov_Model::gamma_d,
                        "",
                        "current of the most conductive state",
                        "the current that goes through each state "
                        "results from multplying the conductance vector by this value");
  }
  
  inline
  void Q_Markov_Model::buildParameters()
  {
    parameters_Map=Markov_IO::Parameters(name_+"_parameters");
    parameters_Map.push_back(gamma_Label(),gamma_d, Markov_IO::Parameters::LOG);
    Markov_LA::ToleranceComparison<double> tol;
    for (std::size_t i=0; i<k_u; i++)
      for (std::size_t j=0; j<k_u; j++)
        {
          if (!(tol.isEqual(Q_M(i,j),0.0))&&(i!=j))
            parameters_Map.push_back(kij_Label(i,j),
                                     Q_M(i,j),
                                     Markov_IO::Parameters::LOG);
        };
  }



  std::multimap<std::size_t,std::size_t> getConnectionMap(const M_Matrix<double>& Q)
  {
    if (Markov_LA::size(Q)>0)
      {
        std::multimap<std::size_t,std::size_t> conn_Map;

        for (std::size_t i=0,n=nrows(Q); i<n; i++)
          {
            for (std::size_t j=i+1; j<n; j++)
              {
                if((Q(i,j)!=0)||(Q(j,i)!=0))
                  {
                    conn_Map.insert(std::pair<std::size_t,std::size_t>(i,j));
                  }
              };
          };
        return conn_Map;
      }
    else
      return {};

  }

  Markov_LA::M_Matrix<double>
  getPartitionVector(Markov_LA::M_Matrix<double> &Q,
                     const std::multimap<std::size_t,std::size_t>&conn_Map,
                     bool& hasloops,
                     bool removeLoops)
  {
    hasloops=false;
    if (Markov_LA::nrows(Q)>0)
      {
        Markov_LA::M_Matrix<double> K=Markov_LA::zeros<double>(Markov_LA::nrows(Q),1);
        K(0,0)=1;
        std::size_t i,j;

        std::multimap<std::size_t,std::size_t>::const_iterator it,itl,itu,itend;
        std::vector<std::multimap<std::size_t,std::size_t>::const_iterator> its,itsend;

        it=conn_Map.begin();
        if (it==conn_Map.end())
          return K;
        i=it->first;
        itend=conn_Map.upper_bound(i);



        bool last=false;
        while(!last)
          {
            i=it->first;
            j=it->second;
            // Calculate the partition function K_M
            if ((Q(i,j)!=0)&&(Q(j,i)!=0))
              {
                if (K(j,0)!=0)
                  {
                    hasloops=true;
                    if (removeLoops)
                      Q(j,i)=0;
                  }
                else
                  K(j,0)=K(i,0)*Q(i,j)/Q(j,i);
              }
            // find out who is connected to j
            itl=conn_Map.lower_bound(j);
            itu=conn_Map.upper_bound(j);

            // if there at least one connected, increase level, switch to it and record previous level
            if (itl!=itu)
              {
                its.push_back(it); // record current connection of state i
                itsend.push_back(itend); // record end connection of state i
                it=itl;  // switch connection
                itend=itu; // switch end connection
              }
            // no, no state k,  k>j, is connected with state j
            else
              {
                // if it is the last connected state, decrease level until there is one more connected state
                while(++it==itend)
                  {
                    // if it is the last level
                    if (its.empty())
                      {
                        last=true;
                        break;
                      }
                    else
                      {
                        // switch to previous level
                        it=its.back();
                        its.pop_back();
                        itend=itsend.back();
                        itsend.pop_back();

                      }
                  }
                //       ++it;
              }
          }


        return K;
      }
    else return{};
  }


  void Q_Markov_Model::Q_conn_K_to_tau_QC()
  {
    tau_Map.clear();
    QC_M=Q_M;
    for(std::multimap<std::size_t,std::size_t>::const_iterator it=conn_Map.begin(); it!=conn_Map.end(); ++it)
      {
        std::size_t i=it->first;
        std::size_t j=it->second;
        if (Q_M(i,j)==0)
          QC_M(i,j)=Q_M(j,i)*K_M[j]/K_M[i];
        else if (Q_M(j,i)==0)
          QC_M(j,i)=Q_M(i,j)*K_M[i]/K_M[j];
        double tau=1.0/(QC_M(i,j)+QC_M(j,i));
        tau_Map[std::pair<std::size_t,std::size_t>(i,j)]=tau;
      }
  }


  void Q_Markov_Model::Q_to_conn_K_tau_QC()
  {
    conn_Map=getConnectionMap(Q_M);
    bool hasloops;
    K_M=getPartitionVector(Q_M, conn_Map,hasloops,true);
    Q_conn_K_to_tau_QC();

  }


  void Q_Markov_Model::QC_to_Q0_Q1()
  {
    QC_M=QC_M-Markov_LA::diag(Markov_LA::diag(QC_M));
    Q0_M=Markov_LA::zeros<double>(QC_M);
    Q1_M=Markov_LA::zeros<double>(QC_M);


    // Now allowing for cycles


    for (std::size_t i=0,n=nrows(QC_M); i<n; i++)
      {
        for (std::size_t j=0; j<n; j++)
          {
            if (QC_M(i,j))
              {
                if (a_M[j]==a_M[i]+1)
                  {
                    Q1_M(i,j)=QC_M(i,j);
                  }
                else
                  {
                    Q0_M(i,j)=QC_M(i,j);
                  };
              }
          };
      };

    Q0_M=Q0_M-Markov_LA::diag(sum(Q0_M));
    Q1_M=Q1_M-Markov_LA::diag(sum(Q1_M));
  }
/*
  Q_Markov_Model& Q_Markov_Model::operator=(const Q_Markov_Model& other)
  {
    if (this != &other)
      {
        Implements_Class_Reflection<Q_Markov_Model>::operator =(other);
        patch_=other.patch_;
        name_=other.name_;
        k_u=other.k_u;
        Q_M=other.Q_M;
        Q0_M=other.Q0_M;
        Q1_M=other.Q1_M;
        QC_M=other.QC_M; //par
        K_M=other.K_M; //par
        conn_Map=other.conn_Map; //par
        tau_Map=other.tau_Map;  // cycles completed

        g_M=other.g_M;
        g0_M=other.g0_M;
        gamma_d=other.gamma_d;
        a_M=other.a_M;
        parameters_Map=other.parameters_Map;
        Q_to_conn_K_tau_QC();
        QC_to_Q0_Q1();
        buildParameters();
        initComplexVar();
      }
    return *this;
  }

*/
  /*
  Q_Markov_Model& Q_Markov_Model::operator=(Q_Markov_Model&& other)
  {
    if (this != &other)
      {
        Implements_Class_Reflection<Q_Markov_Model>::operator =(std::move(other));
        patch_=std::move(other.patch_);
        name_=std::move(other.name_);
        k_u=std::move(other.k_u);
        Q_M=std::move(other.Q_M);
        Q0_M=std::move(other.Q0_M);
        Q1_M=std::move(other.Q1_M);
        QC_M=std::move(other.QC_M); //par
        K_M=std::move(other.K_M); //par
        conn_Map=std::move(other.conn_Map); //par
        tau_Map=std::move(other.tau_Map);  // cycles completed

        g_M=std::move(other.g_M);
        g0_M=std::move(other.g0_M);
        gamma_d=std::move(other.gamma_d);
        a_M=std::move(other.a_M);
        parameters_Map=std::move(other.parameters_Map);
        if (Markov_LA::size(Q0_M)>0)
          {
            Q_to_conn_K_tau_QC();
            QC_to_Q0_Q1();
            buildParameters();
          }
        initComplexVar();
      }
    return *this;
  }

*/
  /*
  Q_Markov_Model& Q_Markov_Model::operator=(const Q_Markov_Model& other)
  {
    if (this != &other)
      {
        *this=Q_Markov_Model(*this);
      }
    return *this;
  }
*/
  //bool Q_Markov_Model::Load(const std::string& file_name)
  //{
  //    Q_Markov_Model tmp;
  //    std::fstream fin;
  //    fin.open(file_name.c_str(),std::ios::in);
  //    assert(fin.is_open() );
  //    std::string s="";
  //    bool valid_input=tmp.get(s,fin);
  //    if (valid_input)
  //    {
  //	swap(*this, tmp);
  //	fin.close();
  //	return true;
  //    }
  //    fin.close();
  //    return false;
  //}


  // I have to decide my police on apply_parameters!!

  ///my policy is the following, apply parameters checks each one of the fields of the
  ///proper parameters it tries to apply each one of the parameters of beta.
  ///it returns the number of used parameters
  int Q_Markov_Model::apply_parameters(const Markov_IO::Parameters& beta)//
  {
    int numPar=0;
    bool noone=true;
    for (std::size_t i=0; i<beta.size(); i++)
      {
        std::string par=beta.Name(i);

        if (parameters_Map.HasName(par))
          {
            if (par==gamma_Label())
              {
                gamma_d=beta[i];
                g_M=g0_M*gamma_d;
                parameters_Map[par]=gamma_d;
                noone=false;
                numPar++;
              }
            else
              {
                size_t state_i, state_j;
                if (get_states_from_kij_Label(par,state_i,state_j))
                  if ((state_i<size(Q_M))&&(state_j<size(Q_M)))
                    {
                      Q_M(state_i,state_j)=beta[i];
                      parameters_Map[par]=beta[i];
                      numPar++;
                      noone=false;
                    }
              };
          }
      };
    if (!noone)
      {
        update();
      }
    return numPar;
  }
  // takes new parameters

  //I/O

/*
  Q_Markov_Model::Q_Markov_Model(const Q_Markov_Model& other):
    Markov_IO::Implements_Class_Reflection<Q_Markov_Model>(other),
    patch_(other.patch_),
    name_(other.name_),
    k_u(other.k_u),
    Q_M(other.Q_M),  //par
    Q0_M(other.Q0_M), //par
    Q1_M(other.Q1_M), //par
    QC_M(other.QC_M), //par
    K_M(other.K_M), //par
    conn_Map(other.conn_Map), //par
    tau_Map(other.tau_Map),  // cycles completed
    g_M (other.g_M), //par
    g0_M (other.g0_M), //par
    gamma_d(other.gamma_d),
    a_M(other.a_M), //par
    parameters_Map(other.parameters_Map)
  {
    initComplexVar();
  }

  Q_Markov_Model::Q_Markov_Model(Q_Markov_Model&& other):
    Markov_IO::Implements_Class_Reflection<Q_Markov_Model>(std::move(other)),
    patch_(std::move(other.patch_)),
    name_(std::move(other.name_)),
    k_u(std::move(other.k_u)),
    Q_M(std::move(other.Q_M)),  //par
    Q0_M(std::move(other.Q0_M)), //par
    Q1_M(std::move(other.Q1_M)), //par
    QC_M(std::move(other.QC_M)), //par
    K_M(std::move(other.K_M)), //par
    conn_Map(std::move(other.conn_Map)), //par
    tau_Map(std::move(other.tau_Map)),  // cycles completed
    g_M (std::move(other.g_M)), //par
    g0_M (std::move(other.g0_M)), //par
    gamma_d(std::move(other.gamma_d)),
    a_M(std::move(other.a_M)), //par
    parameters_Map(std::move(other.parameters_Map))
  {
    initComplexVar();
  }
*/

  Q_Markov_Model::Q_Markov_Model(const ABC_Markov_Model& ABC_Q):
    patch_(ABC_Q.patch()),
    name_(ABC_Q.myName()),
    k_u(ABC_Q.k()),
    Q_M(ABC_Q.Q()),
    Q0_M(ABC_Q.Q0()),
    Q1_M(ABC_Q.Q1()),
    QC_M(M_Matrix<double>()),  // cycles completed
    K_M(M_Matrix<double> ()),// --> indicates the equilibrium function
    conn_Map(std::multimap<std::size_t,std::size_t>()),
    tau_Map(std::map<std::pair<std::size_t,std::size_t> ,double>()), // exchange times

    g_M(ABC_Q.g()),
    a_M(ABC_Q.n_bound_agonists())
  //,parameters_Map(ABC_Q.parameters())
  {
    gamma_d=maxAbs(g_M);
    g0_M=g_M/gamma_d;
    //Q_aux::Q_to_Q0_Q1(Q_M,a_M,Q0_M,Q1_M);
    Q_to_conn_K_tau_QC();
    buildParameters();
    initComplexVar();
  }



  const Markov_IO::Parameters& Q_Markov_Model::get_parameters()const
  {
    return parameters_Map;
  }

  Markov_Transition_rate Q_Markov_Model::Q_x(double x, bool isavergaing)const
  {
    Markov_Transition_rate Qx_value;
    if (isavergaing)
      {
        //        std::cerr<<" {Q_x("<<x<<") : ";
        if (!Q_x_buff_avg.has_X(x))
          {
            //            std::cerr<<" 1";
            if (Q_x_buff_not_avg.has_X(x))
              {

                //              std::cerr<<" 2";
                Qx_value=Q_x_buff_not_avg.get_Y(x);
                //            std::cerr<<" 3";
              }
            else
              {
                Qx_value=get_Q_x_not_avg(x);

              }

            Qx_value=get_Q_x_avg(Qx_value);

            Q_x_buff_avg.put_Y(x, Qx_value);
            //      std::cerr<<" 4 }";
            return Qx_value;
          }
        else
          {
            Qx_value=Q_x_buff_avg.get_Y(x);
            return Qx_value;

          }
      }
    else
      {
        if (!Q_x_buff_not_avg.has_X(x))
          {
            Qx_value=get_Q_x_not_avg(x);
            Q_x_buff_not_avg.put_Y(x, Qx_value);
            return Qx_value;
          }
        else
          {

            Qx_value=Q_x_buff_not_avg.get_Y(x);
            return Qx_value;
          };
      };
  }


  Markov_Transition_step Q_Markov_Model::Q_dt (
      const Markov_IO::ABC_measure_point& xdt_A,
      bool is_averaging,
      bool varying_x,
      bool two_anchor) const
  {
    Markov_IO::x_dt xdt(xdt_A);
    Markov_Transition_step Qdt_;

    if (is_averaging)
      {
        if (varying_x |two_anchor)
          if (two_anchor)
            {
              //         std::cerr<<"\n trans Q_dt varx   :";
              if (!Q_dt_buff_two_anchor.has_X(xdt))
                {
                  if (Q_dt_buff_avg_varx.has_X(xdt))
                    {
                      Qdt_=Q_dt_buff_avg_varx.get_Y(xdt);
                    }
                  else
                    {
                      //           std::cerr<<" 1";
                      if (Q_dt_buff_avg.has_X(xdt))
                        {
                          //             std::cerr<<" 2";
                          Qdt_=Q_dt_buff_avg.get_Y(xdt);
                          //           std::cerr<<" 3";
                        }
                      else
                        {
                          //         std::cerr<<" 4";
                          if (Q_dt_buff_not_avg.has_X(xdt))
                            {
                              //           std::cerr<<" 5";
                              Qdt_=Q_dt_buff_not_avg.get_Y(xdt);
                              //              std::cerr<<" 6";
                            }
                          else
                            {
                              //            std::cerr<<" 7";
                              Qdt_=get_Q_dt_no_avg(xdt);
                              //          std::cerr<<" 8";
                            };
                          //    std::cerr<<" 9";
                          Qdt_=get_Q_dt_avg(xdt,Qdt_);
                          //          std::cerr<<" 10";

                        }
                      //      std::cerr<<" 11";
                      Qdt_=get_Q_dt_avg_var(xdt,Qdt_);
                      //      std::cerr<<" 12";
                      Q_dt_buff_avg_varx.put_Y(xdt,Qdt_);
                      //      std::cerr<<" 13";
                    }
                  Qdt_=get_Q_dt_two_anchor(xdt,Qdt_);
                  Q_dt_buff_two_anchor.put_Y(xdt,Qdt_);
                }
              else
                {
                  //    std::cerr<<" 14";
                  Qdt_=Q_dt_buff_two_anchor.get_Y(xdt);
                  //       std::cerr<<" 15";
                }
              //     std::cerr<<" 16";
              return Qdt_;
            }
          else
            {
              //         std::cerr<<"\n trans Q_dt varx   :";
              if (!Q_dt_buff_avg_varx.has_X(xdt))
                {
                  //           std::cerr<<" 1";
                  if (Q_dt_buff_avg.has_X(xdt))
                    {
                      //             std::cerr<<" 2";
                      Qdt_=Q_dt_buff_avg.get_Y(xdt);
                      //           std::cerr<<" 3";
                    }
                  else
                    {
                      //         std::cerr<<" 4";
                      if (Q_dt_buff_not_avg.has_X(xdt))
                        {
                          //           std::cerr<<" 5";
                          Qdt_=Q_dt_buff_not_avg.get_Y(xdt);
                          //              std::cerr<<" 6";
                        }
                      else
                        {
                          //            std::cerr<<" 7";
                          Qdt_=get_Q_dt_no_avg(xdt);
                          //          std::cerr<<" 8";
                        };
                      //    std::cerr<<" 9";
                      Qdt_=get_Q_dt_avg(xdt,Qdt_);
                      //          std::cerr<<" 10";

                    }
                  //      std::cerr<<" 11";
                  Qdt_=get_Q_dt_avg_var(xdt,Qdt_);
                  //      std::cerr<<" 12";
                  Q_dt_buff_avg_varx.put_Y(xdt,Qdt_);
                  //      std::cerr<<" 13";
                }
              else
                {
                  //    std::cerr<<" 14";
                  Qdt_=Q_dt_buff_avg_varx.get_Y(xdt);
                  //       std::cerr<<" 15";
                }
              //     std::cerr<<" 16";
              return Qdt_;
            }

        else
          {
            if (!Q_dt_buff_avg.has_X(xdt))
              {
                if (Q_dt_buff_not_avg.has_X(xdt))
                  Qdt_=Q_dt_buff_not_avg.get_Y(xdt);
                else
                  {
                    Qdt_=get_Q_dt_no_avg(xdt);
                  }
                Qdt_=get_Q_dt_avg(xdt,Qdt_);

                Q_dt_buff_avg.put_Y(xdt,Qdt_);
              }
            else
              {
                Qdt_=Q_dt_buff_avg.get_Y(xdt);
              };
            return Qdt_;
          }
      }
    else
      {
        if (Q_dt_buff_not_avg.has_X(xdt))
          {
            //    std::cerr<<Qdt_;
            Qdt_=Q_dt_buff_not_avg.get_Y(xdt);
            //   std::cerr<<Qdt_;

          }
        else
          {
            // std::cerr<<Qdt_;
            Qdt_=get_Q_dt_no_avg(xdt);
            Q_dt_buff_not_avg.put_Y(xdt,Qdt_);
            // std::cerr<<Qdt_;

          };
        return Qdt_;
      };
  }

  Markov_Transition_rate& Q_Markov_Model::get_Q_x_avg(Markov_Transition_rate& Qx_value)const
  {
    Qx_value.Wg=Markov_LA::zeros<double>(k_u,1);
    Qx_value.WgV=Markov_LA::zeros<double>(k_u,k_u);

    for (std::size_t k_=0; k_<k_u; k_++)
      {
        for (std::size_t j=0; j<k_u; j++)
          {
            Qx_value.Wg[k_]+=Qx_value.W(k_,j)*g()[j];
          };
      };
    for (std::size_t k_=0; k_<k_u; k_++)
      for (std::size_t k2=0; k2<k_u; k2++)
        {
          for (std::size_t j=0; j<k_u; j++)
            Qx_value.WgV(k_,k2)+=Qx_value.W(k_,j)*g()[j]*Qx_value.V(j,k2);
        };
    return Qx_value;
  }


  Markov_Transition_rate Q_Markov_Model::get_Q_x_not_avg(double x)const
  {
    Markov_Transition_rate Qx_value(k_u,false);
    Qx_value.Qrun=Q0_M+Q1_M*x;
    if (!Markov_LA::isfinite(Qx_value.Qrun))
      return Qx_value;

    double *Er =new double[k_u];
    double *Ei= new double [k_u];
    double *A=new double[k_u*k_u];
    for (size_t i = 0; i < size_t(k_u); i++)
      for (size_t j = 0; j < size_t(k_u); j++)
        *(A+j*k_u+i) =Qx_value.Qrun(i,j);

    char jobvl = 'N';
    char jobvr = 'V';
    int lda = k_u;
    int ldvl = k_u;
    double *vl = new double[k_u*k_u];
    int ldvr = k_u;
    double *vr = new double[k_u*k_u];
    double *work = new double[4*k_u];
    int lwork = 4*k_u;
    int n=k_u;
    int info;
    if (lda==0)
      return Markov_Transition_rate();
    dgeev_(&jobvl, &jobvr, &n, A, &lda, Er, Ei, vl,
           &ldvl, vr, &ldvr, work, &lwork, &info);


    std::multimap<double,std::size_t> la_map;
    for (size_t i=0; i<k_u; i++)
      {
        la_map.insert(std::pair<double,std::size_t>(Er[i],i));
      };

    for(size_t i=0; i<k_u; i++)
      {
        Qx_value.landa[i]=Er[i];
        for(size_t j=0; j<k_u; j++)
          Qx_value.V(i,j) = vr[j*k_u+i];
      } ;
    /*
       for (size_t i = 0; i <k_u; i++)
       {
           std::size_t j=0;
           for (std::multimap<double,std::size_t>::iterator it=la_map.begin(); it!=la_map.end(); ++it)
           {
               Qx_value.landa[j]=it->first;
               Qx_value.V(i,j) = vr[it->second*n+i*k_u];
               j++;
           };
           
       };
      */
    Qx_value.W=Markov_LA::invSafe(Qx_value.V);

    ///we need to sort the eigvalues and eigvectors


    /*

        /// force lai-laj to be either zero or greater than a threshold;
        double la0=0;
        double threshold=maxabs(Qx_value.landa)*sqrt(std::numeric_limits<double>::epsilon());
        //std::cout<<"reigvalues" <<reigvalues<<maxabs<double>(reigvalues)<<"\nthreshold="<<threshold;
        for (size_t i=n; i>0; i--)
        {
            if (std::abs(Er[i]-la0)<threshold)
            {
                Qx_value.landa[i]=la0;
            }
            else
            {
                la0=Qx_value.landa[i];
            };
        };
    */
    delete [] vl;
    delete [] vr;
    delete [] work;
    delete [] A;
    delete [] Er;
    delete [] Ei;

    return Qx_value;
  }

  M_Matrix<double> Q_Markov_Model::Peq(double agonist_concentration) const
  {
    M_Matrix<double> OO=Markov_LA::ones<double>(k_u,k_u);
    M_Matrix<double> SS(k_u,k_u);
    M_Matrix<double> Qrun=Q0_M+Q1_M*agonist_concentration;
    try
    {
      SS=OO*Markov_LA::inv(Qrun+OO);
    }
    catch (Markov_LA::SingularMatrix_error)   // revise this later
    {
      double t=1;
      double tmax=1e6;
      M_Matrix<double> SSdif;
      OO=expm(Qrun*t);
      SS=expm(Qrun*(t*2));
      while (!(SS==OO)&&(t<tmax))
        {
          t*=2;
          OO=SS;
          SS=expm(Qrun*(t*2));
        }
      // std::cerr<<"\n t="<<t<<"  SS=\n"<<SS;
      // std::cerr<<"\n _Qrun="<<Qrun<<"\n";

      // std::cerr<<"\n _Qrun+OO are singular"<<std::endl;
      //assert(false);
    }
    M_Matrix<double> Peq_(Markov_LA::ones<double>(1,k_u)*(1.0/k_u));
    Peq_=Peq_*SS;
    //std::cout<<"Peq before round to zero"<<Peq_;

    round_to_zero(Peq_);
    //std::cout<<"after"<<Peq_;
    //press_any_key_to_continue();
    return Peq_;
  }

  Markov_Transition_step Q_Markov_Model::get_Q_dt_no_avg(
      const Markov_IO::ABC_measure_point& xdt_A) const
  {
    Markov_IO::x_dt xdt(xdt_A);
    Markov_Transition_rate Qx_v(k_u,false);
    Qx_v=Q_x(xdt.x(),false);
    Markov_Transition_step Qdt_v;
    Qdt_v=Markov_Transition_step(k_u,false, false,false);
    //std::cerr<<Qdt_v.P;

    std::vector<double> E00(k_u);
    for (std::size_t i=0; i<k_u; i++)
      E00[i]=std::exp(Qx_v.landa[i]*xdt.dt());

    for (std::size_t i=0; i<k_u; i++)
      for (std::size_t j=0; j<k_u; j++)
        {
          for (std::size_t k1=0; k1<k_u; k1++)
            Qdt_v.P(i,j)+=Qx_v.V(i,k1)*Qx_v.W(k1,j)*E00[k1];
          //std::cerr<<" auqi \n"<<Qdt_v.P(i,j);
          //std::cerr<<Qdt_v.P;
          if (std::abs(Qdt_v.P(i,j))<1e-10)
            Qdt_v.P(i,j)=0.0;
        };
    Qdt_v.gmean_i=g();
    return Qdt_v;
  }

  Markov_Transition_step& Q_Markov_Model::get_Q_dt_avg(
      const Markov_IO::ABC_measure_point& xdt_A,
      Markov_Transition_step& Qdt) const
  {
    x_dt xdt(xdt_A);
    Markov_Transition_rate Qx_v;
    //    std::cerr<<"get_Q_dt_avg 1";
    Qx_v=Q_x(xdt.x(),true);
    //    std::cerr<<Qx_v<<" 2";
    std::vector<double> Wg_E0(k_u);
    Markov_LA::ToleranceComparison<double> tol;

    for (std::size_t k0=0; k0<k_u; k0++)
      {
        double rladt=Qx_v.landa[k0]*xdt.dt();
        if (tol.isEqual(rladt*rladt,0.0))
          Wg_E0[k0]=Qx_v.Wg[k0];
        else
          Wg_E0[k0]=Qx_v.Wg[k0]*(exp(rladt)-1.0)/rladt;
      };
    Qdt.gmean_i=Markov_LA::zeros<double>(k_u,1);
    for (std::size_t k0=0; k0<k_u; k0++)
      {
        for (std::size_t j=0; j<k_u; j++)
          Qdt.gmean_i[k0]+=Qx_v.V(k0,j)*Wg_E0[j];
      }
    //std::cerr<<"\n gmean \n"<<E0<<Qdt.gmean;

    //build E2
    M_Matrix<double> WgV_Wg_E2(k_u,k_u);
    for (std::size_t k0=0; k0<k_u; k0++)
      {
        double rladt=Qx_v.landa[k0]*xdt.dt();
        if (tol.isEqual(rladt*rladt,0.0))
          {
            for (std::size_t k2=0; k2<k_u; k2++)
              {
                double rla2dt=Qx_v.landa[k2]*xdt.dt();
                if (tol.isEqual(rla2dt*rla2dt,0.0))
                  WgV_Wg_E2(k0,k2)=Qx_v.WgV(k0,k2)*
                      Qx_v.Wg[k2]*0.5;
                else
                  WgV_Wg_E2(k0,k2)=Qx_v.WgV(k0,k2)*Qx_v.Wg[k2]*
                      (exp(rla2dt)-rla2dt-1.0)/rla2dt/rla2dt;
              }
          }
        else
          {
            for (std::size_t k2=0; k2<k_u; k2++)
              {
                double rla2dt=Qx_v.landa[k2]*xdt.dt();
                if (tol.isEqual(rla2dt*rla2dt,0.0))
                  {
                    WgV_Wg_E2(k0,k2)=Qx_v.WgV(k0,k2)*Qx_v.Wg[k2]*
                        (exp(rladt)-rladt-1.0)/rladt/rladt;
                  }
                else if (tol.isEqual((rla2dt-rladt)*(rla2dt-rladt),0.0))   //comparing squared difference
                  {
                    WgV_Wg_E2(k0,k2)=Qx_v.WgV(k0,k2)*Qx_v.Wg[k2]*
                        (1.0-exp(rladt)*(1.0-rladt))/rladt/rladt;
                  }
                else
                  {
                    WgV_Wg_E2(k0,k2)=Qx_v.WgV(k0,k2)*Qx_v.Wg[k2]*
                        (1.0/rladt/rla2dt+
                         exp(rla2dt)/rla2dt/(rla2dt-rladt)+
                         exp(rladt)/rladt/(rladt-rla2dt));
                  }
              }
          }
      }
    // vmean(i)=A(k,i,j) g(j) A(k2,j,j2) g(j2) E(k,k)
    // =V(i,k) W(k,j) g(j) V(j,k2) W(k2,j2) g(j2) E(k,k2)
    //         ___________________ ______________
    //         WgV(k,k2)           Wg(k2)
    //___________________________________________________

    // G_(i)=V(i,n1), W(n1,k)g(k) V(k,n2) W(n2,j)       E(n1,n2)
    //                ___________________ ______________
    //                WgV(n1,n2)          W(n2)
    //___________________________________________________

    Qdt.gsqr_i=Markov_LA::zeros<double>(k_u,1);

    for (std::size_t i=0; i<k_u; i++)
      {
        for (std::size_t k0=0; k0<k_u; k0++)
          for (std::size_t k2=0; k2<k_u; k2++)
            Qdt.gsqr_i[i]+=2*Qx_v.V(i,k0)*WgV_Wg_E2(k0,k2);

      }

    Qdt.gvar_i=M_Matrix<double>(k_u,1);
    for (std::size_t i=0; i<k_u; i++)
      Qdt.gvar_i[i]=Qdt.gsqr_i[i]-Qdt.gmean_i[i]*Qdt.gmean_i[i];

    return Qdt;
  }

  Markov_Transition_step& Q_Markov_Model::get_Q_dt_avg_var(const Markov_IO::ABC_measure_point& xdt_A, Markov_Transition_step& Qdt) const
  {
    x_dt xdt(xdt_A);
    // build EE0
    const Markov_Transition_rate Qx=Q_x(xdt.x(),true);
    // build EE0
    M_Matrix<double> E2(k_u,k_u);
    Markov_LA::ToleranceComparison<double> tol;
    for (std::size_t k0=0; k0<k_u; k0++)
      {
        double rladt=Qx.landa[k0]*xdt.dt();
        for (std::size_t k2=0; k2<k_u; k2++)
          {
            double rladt2=Qx.landa[k2]*xdt.dt();
            if (tol.isEqual((rladt-rladt2)*(rladt-rladt2),0.0))
              E2(k0,k2)=exp(rladt2);
            else
              E2(k0,k2)=(exp(rladt)-exp(rladt2))/(rladt-rladt2);
          };
      };
    //std::cerr<<"\nEE0\n"<<EE0;
    Qdt.gtotal_ij=Markov_LA::zeros<double>(k_u,k_u);
    Qdt.gtotal_ij=Qx.V*elemMult(Qx.WgV,E2)*Qx.W;

    /*for (std::size_t i=0; i<k_u; i++)
        for (std::size_t j=0; j<k_u; j++)
            for (std::size_t n1=0; n1<k_u; n1++)
                for (std::size_t n2=0; n2<k_u; n2++)
                    Qdt.G_(i,j)+=2.0*Qx.V(i,n1)*Qx.WgV(n1,n2)*
                                 Qx.W(n2,j)*EE0(n1,n2);
    */
    return Qdt;
  }


  Markov_Transition_step& Q_Markov_Model::get_Q_dt_two_anchor(const Markov_IO::ABC_measure_point& xdt_A, Markov_Transition_step& Qdt) const
  {
    x_dt xdt(xdt_A);
    // build EE0
    const Markov_Transition_rate Qx=Q_x(xdt.x(),true);
    // build EE0

    M_Matrix<double> WgV_E3=Markov_LA::zeros<double>(k_u,k_u);
    Markov_LA::ToleranceComparison<double> tol;
    for (std::size_t n1=0; n1<k_u; n1++)
      {
        double x1=Qx.landa[n1]*xdt.dt();
        double expx1=exp(x1);
        for (std::size_t n3=0; n3<k_u; n3++)
          {
            double x3=Qx.landa[n3]*xdt.dt();
            if (tol.isEqual(x1,x3))
              {
                for (std::size_t n2=0; n2<k_u; n2++)
                  {
                    double x2=Qx.landa[n2]*xdt.dt();
                    if (tol.isEqual(x2,x1))
                      {
                        WgV_E3(n1,n3)+=Qx.WgV(n1,n2)*Qx.WgV(n2,n3)*expx1/2;
                      }
                    else
                      {
                        double expx2=exp(x2);
                        WgV_E3(n1,n3)+=Qx.WgV(n1,n2)*Qx.WgV(n2,n3)*
                            (expx2+expx1*(-x2+x1-1))/(x1-x2)/(x1-x2);
                      };
                  }
              }
            else
              {
                double expx3=exp(x3);
                for (std::size_t n2=0; n2<k_u; n2++)
                  {
                    double x2=Qx.landa[n2]*xdt.dt();
                    if (tol.isEqual(x2,x1))
                      {
                        WgV_E3(n1,n3)+=Qx.WgV(n1,n2)*Qx.WgV(n2,n3)*
                            (expx3+expx1*(-x3+x1-1))/(x1-x3)/(x1-x3);
                      }
                    else if (tol.isEqual(x2,x3))
                      {
                        WgV_E3(n1,n3)+=Qx.WgV(n1,n2)*Qx.WgV(n2,n3)*
                            (expx1+expx3*(x3-x1-1))/(x1-x3)/(x1-x3);
                      }
                    else
                      {
                        double expx2=exp(x2);
                        WgV_E3(n1,n3)+=Qx.WgV(n1,n2)*Qx.WgV(n2,n3)*
                            (expx3*(x1-x2)+expx1*(x2-x3)+
                             expx2*(x3-x1))/((x1-x2)*(x1-x3)*(x2-x3));

                      };
                  };
              };
          };
      };
    //  std::cerr<<"WgV_E3"<<WgV_E3;
    Qdt.gtotal_sqr_ij=(Qx.V*(WgV_E3*2.0)*Qx.W);

    Qdt.gmean_ij=M_Matrix<double>(k_u,k_u);
    Qdt.gvar_ij=M_Matrix<double>(k_u,k_u);
    for (std::size_t i=0; i<k_u; i++)
      for (std::size_t j=0; j<k_u; j++)
        if (Qdt.P(i,j)>1e-9)
          {
            Qdt.gmean_ij(i,j)=Qdt.gtotal_ij(i,j)/Qdt.P(i,j);
            Qdt.gvar_ij(i,j)=Qdt.gtotal_sqr_ij(i,j)/Qdt.P(i,j)-Qdt.gmean_ij(i,j)*Qdt.gmean_ij(i,j);
          }
        else
          {
            Qdt.gmean_ij(i,j)=0;
            Qdt.gvar_ij(i,j)=0;
          }

    M_Matrix<double> u=Markov_LA::ones<double>(k_u,1);
    Qdt.gtotal_var_ij=elemMult(Qdt.gvar_ij,Qdt.P);
    Qdt.gtotal_var_i=Qdt.gtotal_var_ij*u;

    // std::cerr<<Qdt;
    // press_any_key_to_continue();
    return Qdt;
  }


  /**___________________________________________________________________________________________________________

                                    Q_Markov_Model::Q_Model_step Implementation
                                    
---------------______________________________________________________________________________-----------------*/

  /**
  Regular function that computes the Transition probability for a given
  interval of measurements.
  This function is used  to update the knowledge of the distribution of
  states.
  @param xdt is a valid measurment step that contains the evolution of the
  agonist concentration during a given interval of time.
  @param likelihood depending on the bayesian likelihood algorithm different aspects
  of the transition probability are calculated
  @returns an valued object with all the necessary information to perform
    different bayesian analysis during the time interval.
 */
  //Markov_Transition_step  Q_Markov_Model::Q_step (
  //	const Markov_IO::ABC_measure_step& xdt ,
  //	const Markov_Bay::ABC_Markov_Likelihood_step& likelihood)const{};


  Markov_Transition_step Q_Markov_Model::Q_step (const Markov_IO::ABC_measure_step& xdt_A,
                                                 bool is_averaging,
                                                 bool two_anchor)const
  {
    bool varying_x=(xdt_A.num_steps()>1);
    //    std::cerr<<" Q_step: ";
    Markov_Transition_step Qdt=Q_dt(xdt_A.sub_step(0),is_averaging,varying_x, two_anchor);
    if (varying_x)
      {
        if (is_averaging)
          {
            if(two_anchor)
              {
                //	std::cerr<<"susbstep averaging 2 anchor\t"<<xdt_A.sub_step(0)<<"\n";
                double dt=xdt_A.sub_step(0).dt();
                M_Matrix<double> PPn=Qdt.P;
                M_Matrix<double> PG_n=Qdt.gtotal_ij*dt;
                M_Matrix<double> PGG_n=Qdt.gtotal_sqr_ij*(dt*dt*0.5);
                double dtrun=dt;
                for (std::size_t i=1; i<xdt_A.num_steps(); ++i)
                  {
                    //		    std::cerr<<"susbstep averaging 2 anchor\t"<<xdt_A.sub_step(i)<<"\n";

                    dt=xdt_A.sub_step(i).dt();
                    Qdt=Q_dt(xdt_A.sub_step(i),is_averaging,varying_x,two_anchor);
                    PGG_n=(PGG_n*Qdt.P) +(PG_n*Qdt.gtotal_ij)*dt+
                        (PPn*Qdt.gtotal_sqr_ij)*(dt*dt*0.5);
                    PG_n= (PG_n*Qdt.P) + (PPn*Qdt.gtotal_ij)*dt;
                    PPn=PPn*Qdt.P;
                    dtrun+=dt;
                  };

                Qdt.P=PPn;

                Qdt.gtotal_sqr_ij=PGG_n/(dtrun*dtrun*0.5);
                Qdt.gtotal_ij=PG_n/dtrun;
                M_Matrix<double> u=Markov_LA::ones<double>(k_u,1);

                Qdt.gmean_i=Qdt.gtotal_ij*u;
                Qdt.gsqr_i=Qdt.gtotal_sqr_ij*u;
                Qdt.gvar_i=Qdt.gsqr_i-elemMult(Qdt.gmean_i,Qdt.gmean_i);

                Qdt.gmean_ij=M_Matrix<double>(k_u,k_u);
                Qdt.gvar_ij=M_Matrix<double>(k_u,k_u);
                for (std::size_t i=0; i<k_u; i++)
                  for (std::size_t j=0; j<k_u; j++)
                    if (Qdt.P(i,j)>1e-9)
                      {
                        Qdt.gmean_ij(i,j)=Qdt.gtotal_ij(i,j)/Qdt.P(i,j);
                        Qdt.gvar_ij(i,j)=Qdt.gtotal_sqr_ij(i,j)/Qdt.P(i,j)-
                            Qdt.gmean_ij(i,j)*Qdt.gmean_ij(i,j);
                      }
                    else
                      {
                        Qdt.gmean_ij(i,j)=0;
                        Qdt.gvar_ij(i,j)=0;
                      }

                Qdt.gtotal_var_ij=elemMult(Qdt.gvar_ij,Qdt.P);
                Qdt.gtotal_var_i=Qdt.gtotal_var_ij*u;
              }

            else
              {
                //        std::cerr<<"susbstep averaging 1 anchor\t"<<xdt_A.sub_step(0)<<"\n";
                double dt=xdt_A.sub_step(0).dt();
                M_Matrix<double> PPn=Qdt.P;
                M_Matrix<double> PGn=Qdt.gmean_i*dt;
                M_Matrix<double> PG_n=Qdt.gtotal_ij*dt;
                M_Matrix<double> PGGn=Qdt.gsqr_i*(dt*dt);
                //            std::cout<<"\n Qdt.GG_M \n"<<Qdt.GG_M;

                //          std::cout<<"\n gmean_M \n"<<gmean_M;

                //           std::cout<<"\n PGGn \n"<<PGGn;

                double dtrun=dt;
                for (std::size_t i=1; i<xdt_A.num_steps(); ++i)
                  {
                    //         std::cerr<<"susbstep averaging 1 anchor\t"<<xdt_A.sub_step(i)<<"\n";

                    dt=xdt_A.sub_step(i).dt();
                    Qdt=Q_dt(xdt_A.sub_step(i),is_averaging,varying_x);
                    //                std::cout<<"\n Qdt"<<Qdt;
                    PGn+=((PPn*Qdt.gmean_i)*dt);
                    PGGn+=((PPn*Qdt.gsqr_i)*(dt*dt) + (PG_n*Qdt.gmean_i)*dt);
                    PG_n= (PG_n*Qdt.P) + (PPn*Qdt.gtotal_ij)*dt;
                    PPn=PPn*Qdt.P;
                    dtrun+=dt;
                  };
                Qdt.P=PPn;

                Qdt.gmean_i=PGn*(1.0/dtrun);
                PGGn*=(2.0/dtrun/dtrun);
                Qdt.gvar_i=PGGn-elemMult(Qdt.gmean_i,Qdt.gmean_i);
              }
          }
        else
          {
            //     std::cout<<"susbstep non averaging\t"<<xdt_A.sub_step(0)<<"\n";
            M_Matrix<double> PPn=Qdt.P;
            for (std::size_t i=1; i<xdt_A.num_steps(); ++i)
              {
                //                std::cerr<<"susbstep non averaging\t"<<xdt_A.sub_step(i)<<"\n";
                Qdt=Q_dt(xdt_A.sub_step(i),is_averaging,varying_x);
                PPn=PPn*Qdt.P;
              };
            Qdt.P=PPn;
          };
      };
    return Qdt;
  }

  Markov_state Q_Markov_Model::start(double equilibrium_concentration,
                                     std::size_t Nchannels,
                                     Borrowed::MersenneTwister::MTRand& sto)const
  {
    Markov_state M;

    M.N()=random_N_sample(this->Peq(equilibrium_concentration), Nchannels,sto);
    M.P()=Peq(equilibrium_concentration);
    M.ymean()=(M.N()*this->g())[0];
    return M;
  }

  Markov_state_ext Q_Markov_Model::start(double equilibrium_concentration,
                                         std::size_t Nchannels,
                                         Borrowed::MersenneTwister::MTRand& sto, bool)const
  {
    Markov_state_ext M(k_u);
    M.N=random_N_sample(this->Peq(equilibrium_concentration), Nchannels,sto);
    M.P=Peq(equilibrium_concentration);
    M.ymean=(M.N*this->g())[0];
    return M;
  }

  Markov_state& Q_Markov_Model::run(const Markov_IO::ABC_measure_point& xdt,
                                    Markov_state& N_run,
                                    std::size_t n_steps,
                                    Borrowed::MersenneTwister::MTRand& sto
                                    )const
  {
    double ddt=xdt.dt()/n_steps;
    x_dt xddt(ddt,xdt.x());
    Markov_Transition_step Qddt=Q_dt(xddt,false,false);
    if (Qddt.P[0]==0)
      {
        //std::cout<<Qddt;
        //std::cout<<"xddt \n"<<xddt;
        Markov_Transition_step Qddt2=Q_dt(xddt,false,false);
        //press_any_key_to_continue();
        //std::cout<<Qddt2;
        //press_any_key_to_continue();
        //std::cout<<*this;
        //std::cout<<"Peq"<<Peq(0.0);
        //press_any_key_to_continue();
      }
    double ysum=0;
    for (std::size_t i=0; i<n_steps; i++)
      {
        N_run.N()=random_P_on_N(Qddt,N_run.N(),sto);

        ysum+=(N_run.N()*g())[0];
        N_run.P()=N_run.P()*Qddt.P;
      }
    N_run.ymean()=ysum/n_steps;
    return N_run;
  }

  Markov_state& Q_Markov_Model::run(const Markov_IO::ABC_measure_step& xdt,
                                    Markov_state& N_run,
                                    std::size_t n_steps,
                                    Borrowed::MersenneTwister::MTRand& sto)const
  {
    double ysum=0;
    double tsum=0;
    for (std::size_t i=0; i<xdt.num_steps(); i++)
      {
        std::size_t nst=std::max(std::size_t(n_steps*xdt.sub_step(i).dt()/xdt.dt()),std::size_t(1));
        N_run=run(xdt.sub_step(i),N_run,nst,sto);
        ysum+=N_run.ymean()*xdt.sub_step(i).dt();
        tsum+=xdt.sub_step(i).dt();
      }
    N_run.ymean()=ysum/tsum;
    return N_run;
  }

  Markov_state_ext& Q_Markov_Model::run(const Markov_IO::ABC_measure_point& xdt,
                                        Markov_state_ext& N_run,
                                        std::size_t n_steps,
                                        Borrowed::MersenneTwister::MTRand& sto)const
  {
    N_run.ymean=0.0;
    N_run.ysqr=0.0;
    N_run.N_mean=0.0;
    N_run.N_sqr=0.0;
    double ddt=xdt.dt()/n_steps;
    x_dt xddt(ddt,xdt.x());
    Markov_Transition_step Qddt=Q_dt(xddt,false,false);
    for (std::size_t i=0; i<n_steps; i++)
      {
        N_run.N=random_P_on_N(Qddt,N_run.N,sto);
        double y=(N_run.N*g())[0];
        N_run.N_mean+=N_run.N;
        N_run.N_sqr+=elemMult(N_run.N,N_run.N);
        N_run.ymean+=y;
        N_run.ysqr+=y*y;
        N_run.P=N_run.P*Qddt.P;
      }
    N_run.ymean=N_run.ymean/double(n_steps);
    N_run.ysqr=N_run.ysqr/double(n_steps);
    N_run.N_mean=N_run.N_mean/double(n_steps);
    N_run.N_sqr=N_run.N_sqr/double(n_steps);

    N_run.ystd=sqrt(N_run.ysqr-N_run.ymean*N_run.ymean);
    for (std::size_t i=0; i<k_u; i++)
      {
        N_run.N_std[i]=sqrt(N_run.N_sqr[i]-N_run.N_mean[i]*N_run.N_mean[i]);
      };
    return N_run;
  }

  Markov_state_ext& Q_Markov_Model::run(const Markov_IO::ABC_measure_step& xdt,
                                        Markov_state_ext& N_run,
                                        std::size_t n_steps,
                                        Borrowed::MersenneTwister::MTRand& sto)const
  {
    if (xdt.num_steps()>1)
      {
        double ysum=0;
        double tsum=0;
        double ysqrsum=0;
        M_Matrix<double> Nsum=Markov_LA::zeros<double>(1,k_u);
        M_Matrix<double> Nsqrsum=Markov_LA::zeros<double>(1,k_u);
        for (std::size_t i=0; i<xdt.num_steps(); i++)
          {
            N_run=run(xdt.sub_step(i),N_run,n_steps,sto);
            ysum+=N_run.ymean*xdt.dt();
            ysqrsum+=N_run.ysqr*xdt.dt();
            Nsum+=N_run.N_mean*xdt.dt();
            Nsqrsum+=N_run.N_sqr*xdt.dt();
            tsum+=xdt.dt();
          }
        N_run.ymean=ysum/tsum;
        N_run.N_mean=Nsum/tsum;
        N_run.N_sqr=Nsqrsum/tsum;
        N_run.ysqr=ysqrsum/tsum;
        N_run.ystd=sqrt(N_run.ysqr-N_run.ymean*N_run.ymean);
        for (std::size_t i=0; i<k_u; i++)
          {
            N_run.N_std[i]=sqrt((N_run.N_sqr[i]-N_run.N_mean[i]*N_run.N_mean[i]));
          };
      }
    else
      {
        N_run=run(xdt.sub_step(0),N_run,n_steps,sto);
      };
    return N_run;
  }


  std::string Q_Markov_Model::gamma_Label()
  {
    return  "unitary_conductance";
  }

  bool Q_Markov_Model::loadFromComplexVar(const Markov_IO::ABC_Var *source)
  {
    if (sameFields(source))
      {
        decltype(Q_M) Q;
        decltype(g0_M) g;
        decltype(a_M) a;
        double gamma;
        bool bQ=source->getValue("Q_matrix",Q);
        auto bg=source->getValue("conductance_vector",g);
        bool ba=source->getValue("agonist_vector",a);
        bool bgamma=source->getValue("unitary_conductance", gamma);

        if (bQ&&bg&&ba&&bgamma)
          {
            *this=Q_Markov_Model(parentVar(),source->id(),Q,g,a,gamma);
            return true;
          }
        return false;
      }
    else
      return false;
  }
  //std::ostream& Q_Markov_Model::put(std::ostream&s) const
  //{

  //}

  // Markov_Transition_step Q_Markov_Model::Q_dt(
  //	const Markov_IO::ABC_measure_point& xdt,
  //	const Markov_Bay::ABC_Markov_Likelihood_step& likelihood)const{}



  //std::string Q_Markov_Model::DirName()const
  //{
  //    return dirName_;
  //}
  //std::string Q_Markov_Model::Author()const
  //{
  //    return author_;
  //}
  //std::string Q_Markov_Model::Date()const
  //{
  //    return date_;
  //}
  //std::string Q_Markov_Model::Id()const
  //{
  //    return id_;
  //}

  //std::string Q_Markov_Model::Extension()const
  //{
  //     return "experiment";
  //}

  //std::string Q_Markov_Model::FileName()const
  //{
  //    return Markov_IO::ABC_Saveable::FileName();
  //}


  ClassDescription Q_Markov_Model::GetDescription()const
  {
    ClassDescription desc(myClass(),mySuperClass());
    desc.push_back("name",name_,
                   "descriptive name","reference name no definite purpose");
    desc.push_back("Q_matrix",
                   Q_M,
                   "[1/s] or [1/s/uM]",
                   "rate constant matrix in a 1 micromolar solution",
                   "Q-matrix is a square matrix of k dimensions, where Q(i,j) represents the"
                   "rate constant for going from the state i to the state j in a 1 micromolar"
                   "solution of the agonist");
    desc.push_back("conductance_vector",
                   g0_M,
                   "[pA/pA]",
                   "current for each state, a zero value for the closed states, "
                   "one for fully open, between zero and one for partially open states",
                   "a column vector of k elements g(i) representing the single "
                   "channel current for the state i, expressed as the ratio of "
                   "the maximal current generated by any state");
    desc.push_back("agonist_vector",
                   a_M,
                   "[number of bound molecules]"
                   "number of agonist bound to each state",
                   "this information is used to determine which rate constants are dependent "
                   "upon the agonist concentration");
    desc.push_back("unitary_conductance",
                   gamma_d,
                   "[pA]",
                   "current of the most conductive state",
                   "the current that goes through each state "
                   "results from multplying the conductance vector by this value");



    return desc;


  }

  std::string Q_Markov_Model::ClassName()
  {
    return "Q_Markov_Model";
  }

  std::string Q_Markov_Model::myName()const
  {
    return name_;
  }

  std::string Q_Markov_Model::myClass()const
  {
    return ClassName();
  }




  bool Q_Markov_Model::LoadFromDescription(const ClassDescription& classDes)
  {
    if (classDes.ClassName()!=myClass())
      {

        return false;
      }
    std::string name;
    if (!ToValue(classDes["name"],name))
      return false;

    M_Matrix<double> Q_matrix;
    if (!ToValue(classDes["Q_matrix"],Q_matrix))
      return false;

    M_Matrix<double> conductance_vector;
    if (!ToValue(classDes["conductance_vector"],conductance_vector))
      return false;

    M_Matrix<std::size_t> agonist_vector;
    if (!ToValue(classDes["agonist_vector"],agonist_vector))
      return false;

    double unitary_conductance;
    if (!ToValue(classDes["unitary_conductance"],unitary_conductance))
      return false;


    Q_Markov_Model temp(parentVar(),
                        name,
                        Q_matrix,
                        conductance_vector,
                        agonist_vector,
                        unitary_conductance);

    *this=std::move(temp);

    return true;
  }

  bool Q_Markov_Model::LoadFromStringDescription(
      const ClassDescription& classDes)
  {
    if (classDes.ClassName()!=myClass())
      {

        return false;
      }
    std::string name;
    if (!ToValue(classDes["name"],name))
      return false;

    std::string Q_matrix;
    if (!ToValue(classDes["Q_matrix"],Q_matrix))
      return false;

    std::string conductance_vector;
    if (!ToValue(classDes["conductance_vector"],conductance_vector))
      return false;

    std::string agonist_vector;
    if (!ToValue(classDes["agonist_vector"],agonist_vector))
      return false;

    std::string unitary_conductance;
    if (!ToValue(classDes["unitary_conductance"],unitary_conductance))
      return false;


    *this=Q_Markov_Model(parentVar(),
                         name,
                         M_Matrix<double>(Q_matrix),
                         M_Matrix<double>(conductance_vector),
                         M_Matrix<std::size_t>(agonist_vector),
                         atof(unitary_conductance.c_str()));

    return true;
  }



}

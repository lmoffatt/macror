#include <fstream>

#include "Markov_Mol/QMarkovModel.h"
#include "Markov_Mol/QAux.h"

#include "Markov_LA/matrixAritmetic.h"
#include "Markov_LA/matrixInit.h"
#include "Markov_LA/matrixSum.h"
#include "Markov_LA/matrixMaxMin.h"
#include "Markov_LA/matrixInverse.h"
#include "Markov_LA/matrixProduct.h"
#include "Markov_LA/matrixExp.h"
#include "Markov_LA/matrixRounding.h"
#include "Markov_LA/matrixOperators.h"

#include "Markov_LA/auxiliarRelational.h"

#include "Markov_IO/ClassDescription.h"
#include "Markov_IO/auxiliarIO.h"


namespace Markov_Mol
{
using Markov_LA::zeros;
using Markov_LA::diag;
using Markov_LA::ones;

using Markov_IO::ABC_measure_point;
using Markov_IO::ABC_measure_step;





extern "C" void dgeev_(char *jobvl,
		       char *jobvr,
		       int *n,
		       double *a,
		       int *lda,
		       double *wr,
		       double *wi,
		       double *vl,
		       int *ldvl,
		       double *vr,
		       int *ldvr,
		       double *work,
		       int *lwork,
		       int *info);



std::string num_channels_label()
{
    return "Number of channels";
}


Q_Markov_Model* Q_Markov_Model::clone() const
{
    return new Q_Markov_Model(*this);
};
Q_Markov_Model* Q_Markov_Model::create() const
{
    return new Q_Markov_Model();
};


//std::string Q_Markov_Model::name()const
//{
//    return this->name_;
//};

///**
//  Author of the last modification of the model.
//  The author of the model is defined as either the first author of the
//  original publication from where the model have been taken verbatim, or
//  just the operator of the program. If the model is modified somehow (by the
//  function setParameters the author is then the operator of the program.
//  @returns a string with the last name of the author of the model
//  */
//std::string Q_Markov_Model::author()const{
//return author_;
//};


///**
//  Date of the last modification to the model.
//  If the model follows exactly a published model, we take the earliest date
//  of reception of the paper. If the model does not follow strictly the
//  published model, it returns the earliest date with the same parameters.
//  If the model is modified, the date is updated.
//  @returns the date in the format YYYYMMDD
// */
//std::string Q_Markov_Model::date()const{
//return date_;
//};


///**
//  Name of the file for saving the model
//  @returns Author+data+id_number
//  It forms a string with the Author(),date() and an idnumer()
//  */
//std::string Q_Markov_Model::fname()const
//{
//    return author_+date_;
//}






//const Publication& Q_Markov_Model::pub()const
//{
//    return Pub_P;
//};

/// This function returns the cannonical labels for the different arguments  of the object constructor





///**  Saves the model with an specified format
//     @param dirName the complete address of the directory where the model is
//     to be saved. The model name is generated by the function fname.
//     containing the object is to be written.
//     @param extension indicates the format of the file
//     @post the model is written in the file in such a way that it can be
//     reconstructed, so it can be written
//	   @verbatim
//	   // ABC_Markov_Model is abstract, so we need a derived class
//	   Class_Derived_From_ABC_Markov_Model modelAlreadyThere;
//	   //save on any place
//	   std::string fname=model.save("C:\myDir", "xml");
//	   // it will create a filename based on
//	   Class_Derived_From_ABC_Markov_Model emptyModel;
//	   emptyModel.load("C:\myDir\Myself_20110226_1.model.xml");
//	   assert(emptyModel==model);
//	   @endverbatim
//      @returns a string with the name of the file where the model was saved
//      or an empty string if failed.
//  */
//std::string Q_Markov_Model::save(const std::string& dirName,
//				 const std::string& extension){};















Q_Markov_Model::Q_Markov_Model():
	k_u(0),
	Q_M(M_Matrix<double>()),
	Q0_M(M_Matrix<double>()),
	Q1_M(M_Matrix<double>()),
	g_M(M_Matrix<double>()),
	g0_M(M_Matrix<double>()),
	a_M(M_Matrix<size_t>())
{
};

Q_Markov_Model::~Q_Markov_Model() {};



std::size_t Q_Markov_Model::k()const
{
    return k_u;
}

const M_Matrix<double>& Q_Markov_Model::Q() const
{
    return Q_M;
}


const M_Matrix<double>& Q_Markov_Model::Q0() const
{
    return Q0_M;
}


const M_Matrix<double>& Q_Markov_Model::Q1() const
{
    return Q1_M;
}


const M_Matrix<size_t>& Q_Markov_Model::n_bound_agonists() const
{
    return a_M;
}


const M_Matrix<double>& Q_Markov_Model::g() const
{

    return g_M;//*gamma_d;
}


double Q_Markov_Model::gamma() const
{
    return gamma_d;
}


std::string Q_Markov_Model::kij_Label(std::size_t i,std::size_t j)
{
    if ((i<k_u)&&(j<k_u))
    {
	std::string kij="k_"+Markov_IO::ToString(i)+
			"_to_"+Markov_IO::ToString(j);
	return kij;
    }
    else
    {
	std::string msg="i or j too big";
	return msg;
    };
}


/// constructor
Q_Markov_Model::Q_Markov_Model(const std::string& model_name_identifier,
			       const M_Matrix<double>& Q_matrix,
			       const M_Matrix<double>& conductance_vector,
			       const M_Matrix<std::size_t>& agonist_vector,
			       double unitary_conductance):
    name_(model_name_identifier),
    k_u(nrows(Q_matrix)),
    Q_M(Q_matrix),
    Q0_M(M_Matrix<double>(k_u,k_u)),
    Q1_M(M_Matrix<double>(k_u,k_u)),
    g_M(conductance_vector*unitary_conductance),
    g0_M(conductance_vector),
    gamma_d(unitary_conductance),
    a_M(agonist_vector),
    parameters_Map()
{

    Q_to_Q0_Q1();
    buildParameters();
}


inline
bool Q_Markov_Model::get_states_from_kij_Label(std::string kij,std::size_t& i,std::size_t& j)
{
    if (kij.find("k_")!=0) return false;
    std::size_t pos=kij.find("_to_");
    if (pos==std::string::npos) return false;
    std::string s=kij.substr(2,pos-2);
    if (!Markov_IO::ToValue<std::size_t>(s,i))
	return false;
    s=kij.substr(pos+4);
    if (!Markov_IO::ToValue<std::size_t>(s,j))
	    return false;
    return true;
}

inline
void
Q_Markov_Model::update()
{
    Q_to_Q0_Q1();
    Q_dt_buff_avg.reset();
    Q_dt_buff_two_anchor.reset();
    Q_dt_buff_avg_varx.reset();
    Q_dt_buff_not_avg.reset();
    Q_x_buff_avg.reset();
    Q_x_buff_not_avg.reset();
}

inline
void Q_Markov_Model::buildParameters()
{
    parameters_Map=Markov_IO::Parameters();
    parameters_Map.push_back(gamma_Label(),gamma_d);
    Markov_LA::ToleranceComparison<double> tol;
    for (std::size_t i=0; i<k_u; i++)
	for (std::size_t j=0; j<k_u; j++)
	{
	    if (!(tol.isEqual(Q_M(i,j),0.0)))
		parameters_Map.push_back(kij_Label(i,j),Q_M(i,j));
	};
}

void Q_Markov_Model::Q_to_Q0_Q1()
{
    Q0_M=zeros<double>(Q_M);
    Q1_M=zeros<double>(Q_M);
    for (std::size_t i=0,n=nrows(Q_M); i<n; i++)
    {
	for (std::size_t j=0; j<n; j++)
	{
	    if (Q_M(i,j))
	    {
		if (a_M[j]==a_M[i]+1)
		{
		    Q1_M(i,j)=Q_M(i,j);
		}
		else
		{
		    Q0_M(i,j)=Q_M(i,j);
		};
	    }
	};
    };

    Q0_M=Q0_M-diag(sum(Q0_M));
    Q1_M=Q1_M-diag(sum(Q1_M));
}

Q_Markov_Model& Q_Markov_Model::operator=(const Q_Markov_Model& other)
{
    if (this != &other)
    {
	Q_Markov_Model tmp(other);
	swap(*this, tmp);
    }
    return *this;
}

//bool Q_Markov_Model::Load(const std::string& file_name)
//{
//    Q_Markov_Model tmp;
//    std::fstream fin;
//    fin.open(file_name.c_str(),std::ios::in);
//    assert(fin.is_open() );
//    std::string s="";
//    bool valid_input=tmp.get(s,fin);
//    if (valid_input)
//    {
//	swap(*this, tmp);
//	fin.close();
//	return true;
//    }
//    fin.close();
//    return false;
//}


// I have to decide my police on apply_parameters!!

///my policy is the following, apply parameters checks each one of the fields of the
///proper parameters it tries to apply each one of the parameters of beta.
///it returns all the unused parameters
int Q_Markov_Model::apply_parameters(const Markov_IO::Parameters& beta)//
{
    bool noone=true;
    for (std::size_t i=0; i<beta.size(); i++)
    {
	std::string par=beta.par(i);

	if (parameters_Map.has_par(par))
	{
	    if (par=="gamma")
	    {
		gamma_d=beta[i];
		g_M=g0_M*gamma_d;
		parameters_Map[par]=gamma_d;
	    }
	    else
	    {
		size_t state_i, state_j;
		if (get_states_from_kij_Label(par,state_i,state_j))
		    if ((state_i<size(Q_M))&&(state_j<size(Q_M)))
		    {
			Q_M(state_i,state_j)=beta[i];
			parameters_Map[par]=beta[i];
			noone=false;
		    }
	    };
	}
    };
    if (!noone)
    {
	update();
	return 0;
    }
    return -1;
}
// takes new parameters

//I/O


Q_Markov_Model::Q_Markov_Model(const Q_Markov_Model& other):
    k_u(other.k_u),
    Q_M(other.Q_M),  //par
    Q0_M(other.Q0_M), //par
    Q1_M(other.Q1_M), //par
    g_M (other.g_M), //par
    g0_M (other.g_M), //par
    gamma_d(other.gamma_d),
    a_M(other.a_M), //par
    parameters_Map(other.parameters_Map)
{
}

Q_Markov_Model::Q_Markov_Model(const ABC_Markov_Model& ABC_Q):
    k_u(ABC_Q.k()),
    Q_M(ABC_Q.Q()),
    Q0_M(ABC_Q.Q0()),
    Q1_M(ABC_Q.Q1()),
    g_M(ABC_Q.g()),
    a_M(ABC_Q.n_bound_agonists())
    //,parameters_Map(ABC_Q.parameters())
{
    gamma_d=maxAbs(g_M);
    g0_M=g_M/gamma_d;
    //Q_aux::Q_to_Q0_Q1(Q_M,a_M,Q0_M,Q1_M);
    buildParameters();
}

void swap(Q_Markov_Model& X,Q_Markov_Model& Y)
{
    std::swap(X.k_u,Y.k_u);
    swap(X.Q_M,Y.Q_M);
    swap(X.Q0_M,Y.Q0_M);
    swap(X.Q1_M,Y.Q1_M);
    swap(X.g_M,Y.g_M);
    swap(X.g0_M,Y.g0_M);
    swap(X.a_M,Y.a_M);
    std::swap(X.gamma_d,Y.gamma_d);
    swap(X.parameters_Map,Y.parameters_Map);
}



const Markov_IO::Parameters& Q_Markov_Model::get_parameters()const
{
    return parameters_Map;
}

Markov_Transition_rate Q_Markov_Model::Q_x(double x, bool isavergaing)const
{
    Markov_Transition_rate Qx_value;
    if (isavergaing)
    {
//        std::cerr<<" {Q_x("<<x<<") : ";
	if (!Q_x_buff_avg.has_X(x))
	{
//            std::cerr<<" 1";
	    if (Q_x_buff_not_avg.has_X(x))
	    {

		//              std::cerr<<" 2";
		Qx_value=Q_x_buff_not_avg.get_Y(x);
		//            std::cerr<<" 3";
	    }
	    else
	    {
		Qx_value=get_Q_x_not_avg(x);

	    }

	    Qx_value=get_Q_x_avg(x,Qx_value);

	    Q_x_buff_avg.put_Y(x, Qx_value);
	    //      std::cerr<<" 4 }";
	    return Qx_value;
	}
	else
	{
	    Qx_value=Q_x_buff_avg.get_Y(x);
	    return Qx_value;

	}
    }
    else
    {
	if (!Q_x_buff_not_avg.has_X(x))
	{
	    Qx_value=get_Q_x_not_avg(x);
	    Q_x_buff_not_avg.put_Y(x, Qx_value);
	    return Qx_value;
	}
	else
	{

	    Qx_value=Q_x_buff_not_avg.get_Y(x);
	    return Qx_value;
	};
    };
}


Markov_Transition_step Q_Markov_Model::Q_dt (
	const Markov_IO::ABC_measure_point& xdt_A,
	bool is_averaging,
	bool varying_x,
	bool two_anchor) const
{
    Markov_IO::x_dt xdt(xdt_A);
    Markov_Transition_step Qdt_;

    if (is_averaging)
    {
	if (varying_x |two_anchor)
	    if (two_anchor)
	    {
		//         std::cerr<<"\n trans Q_dt varx   :";
		if (!Q_dt_buff_two_anchor.has_X(xdt))
		{
		    if (Q_dt_buff_avg_varx.has_X(xdt))
		    {
			Qdt_=Q_dt_buff_avg_varx.get_Y(xdt);
		    }
		    else
		    {
			//           std::cerr<<" 1";
			if (Q_dt_buff_avg.has_X(xdt))
			{
			    //             std::cerr<<" 2";
			    Qdt_=Q_dt_buff_avg.get_Y(xdt);
			    //           std::cerr<<" 3";
			}
			else
			{
			    //         std::cerr<<" 4";
			    if (Q_dt_buff_not_avg.has_X(xdt))
			    {
				//           std::cerr<<" 5";
				Qdt_=Q_dt_buff_not_avg.get_Y(xdt);
				//              std::cerr<<" 6";
			    }
			    else
			    {
				//            std::cerr<<" 7";
				Qdt_=get_Q_dt_no_avg(xdt);
				//          std::cerr<<" 8";
			    };
			    //    std::cerr<<" 9";
			    Qdt_=get_Q_dt_avg(xdt,Qdt_);
			    //          std::cerr<<" 10";

			}
			//      std::cerr<<" 11";
			Qdt_=get_Q_dt_avg_var(xdt,Qdt_);
			//      std::cerr<<" 12";
			Q_dt_buff_avg_varx.put_Y(xdt,Qdt_);
			//      std::cerr<<" 13";
		    }
		    Qdt_=get_Q_dt_two_anchor(xdt,Qdt_);
		    Q_dt_buff_two_anchor.put_Y(xdt,Qdt_);
		}
		else
		{
		    //    std::cerr<<" 14";
		    Qdt_=Q_dt_buff_two_anchor.get_Y(xdt);
		    //       std::cerr<<" 15";
		}
		//     std::cerr<<" 16";
		return Qdt_;
	    }
	    else
	    {
		//         std::cerr<<"\n trans Q_dt varx   :";
		if (!Q_dt_buff_avg_varx.has_X(xdt))
		{
		    //           std::cerr<<" 1";
		    if (Q_dt_buff_avg.has_X(xdt))
		    {
			//             std::cerr<<" 2";
			Qdt_=Q_dt_buff_avg.get_Y(xdt);
			//           std::cerr<<" 3";
		    }
		    else
		    {
			//         std::cerr<<" 4";
			if (Q_dt_buff_not_avg.has_X(xdt))
			{
			    //           std::cerr<<" 5";
			    Qdt_=Q_dt_buff_not_avg.get_Y(xdt);
			    //              std::cerr<<" 6";
			}
			else
			{
			    //            std::cerr<<" 7";
			    Qdt_=get_Q_dt_no_avg(xdt);
			    //          std::cerr<<" 8";
			};
			//    std::cerr<<" 9";
			Qdt_=get_Q_dt_avg(xdt,Qdt_);
			//          std::cerr<<" 10";

		    }
		    //      std::cerr<<" 11";
		    Qdt_=get_Q_dt_avg_var(xdt,Qdt_);
		    //      std::cerr<<" 12";
		    Q_dt_buff_avg_varx.put_Y(xdt,Qdt_);
		    //      std::cerr<<" 13";
		}
		else
		{
		    //    std::cerr<<" 14";
		    Qdt_=Q_dt_buff_avg_varx.get_Y(xdt);
		    //       std::cerr<<" 15";
		}
		//     std::cerr<<" 16";
		return Qdt_;
	    }

	else
	{
	    if (!Q_dt_buff_avg.has_X(xdt))
	    {
		if (Q_dt_buff_not_avg.has_X(xdt))
		    Qdt_=Q_dt_buff_not_avg.get_Y(xdt);
		else
		{
		    Qdt_=get_Q_dt_no_avg(xdt);
		}
		Qdt_=get_Q_dt_avg(xdt,Qdt_);

		Q_dt_buff_avg.put_Y(xdt,Qdt_);
	    }
	    else
	    {
		Qdt_=Q_dt_buff_avg.get_Y(xdt);
	    };
	    return Qdt_;
	}
    }
    else
    {
	if (Q_dt_buff_not_avg.has_X(xdt))
	{
	//    std::cerr<<Qdt_;
	    Qdt_=Q_dt_buff_not_avg.get_Y(xdt);
	 //   std::cerr<<Qdt_;

	}
	else
	{
	   // std::cerr<<Qdt_;
    Qdt_=get_Q_dt_no_avg(xdt);
	    Q_dt_buff_not_avg.put_Y(xdt,Qdt_);
	   // std::cerr<<Qdt_;

	};
	return Qdt_;
    };
}

Markov_Transition_rate& Q_Markov_Model::get_Q_x_avg(double x, Markov_Transition_rate& Qx_value)const
{
    Qx_value.Wg=zeros<double>(k_u,1);
    Qx_value.WgV=zeros<double>(k_u,k_u);

    for (std::size_t k_=0; k_<k_u; k_++)
    {
	for (std::size_t j=0; j<k_u; j++)
	{
	    Qx_value.Wg[k_]+=Qx_value.W(k_,j)*g()[j];
	};
    };
    for (std::size_t k_=0; k_<k_u; k_++)
	for (std::size_t k2=0; k2<k_u; k2++)
	{
	    for (std::size_t j=0; j<k_u; j++)
		Qx_value.WgV(k_,k2)+=Qx_value.W(k_,j)*g()[j]*Qx_value.V(j,k2);
	};
    return Qx_value;
}


Markov_Transition_rate Q_Markov_Model::get_Q_x_not_avg(double x)const
{
    Markov_Transition_rate Qx_value(k_u,false);
    Qx_value.Qrun=Q0_M+Q1_M*x;

    double *Er =new double[k_u];
    double *Ei= new double [k_u];
    double *A=new double[k_u*k_u];
    for (size_t i = 0; i < size_t(k_u); i++)
	for (size_t j = 0; j < size_t(k_u); j++)
	    *(A+j*k_u+i) =Qx_value.Qrun(i,j);

    char jobvl = 'N';
    char jobvr = 'V';
    int lda = k_u;
    int ldvl = k_u;
    double *vl = new double[k_u*k_u];
    int ldvr = k_u;
    double *vr = new double[k_u*k_u];
    double *work = new double[4*k_u];
    int lwork = 4*k_u;
    int n=k_u;
    int info;
    dgeev_(&jobvl, &jobvr, &n, A, &lda, Er, Ei, vl,
	   &ldvl, vr, &ldvr, work, &lwork, &info);


    std::multimap<double,std::size_t> la_map;
    for (size_t i=0; i<k_u; i++)
    {
	la_map.insert(std::pair<double,std::size_t>(Er[i],i));
    };

    for(size_t i=0; i<k_u; i++)
    {
	Qx_value.landa[i]=Er[i];
	for(size_t j=0; j<k_u; j++)
	    Qx_value.V(i,j) = vr[j*k_u+i];
    } ;
    /*
       for (size_t i = 0; i <k_u; i++)
       {
	   std::size_t j=0;
	   for (std::multimap<double,std::size_t>::iterator it=la_map.begin(); it!=la_map.end(); ++it)
	   {
	       Qx_value.landa[j]=it->first;
	       Qx_value.V(i,j) = vr[it->second*n+i*k_u];
	       j++;
	   };

       };
      */
    Qx_value.W=inv(Qx_value.V);

    ///we need to sort the eigvalues and eigvectors


    /*

	/// force lai-laj to be either zero or greater than a threshold;
	double la0=0;
	double threshold=maxabs(Qx_value.landa)*sqrt(std::numeric_limits<double>::epsilon());
	//std::cout<<"reigvalues" <<reigvalues<<maxabs<double>(reigvalues)<<"\nthreshold="<<threshold;
	for (size_t i=n; i>0; i--)
	{
	    if (std::abs(Er[i]-la0)<threshold)
	    {
		Qx_value.landa[i]=la0;
	    }
	    else
	    {
		la0=Qx_value.landa[i];
	    };
	};
    */
    delete [] vl;
    delete [] vr;
    delete [] work;
    delete [] A;
    delete [] Er;
    delete [] Ei;

    return Qx_value;
}

M_Matrix<double> Q_Markov_Model::Peq(double agonist_concentration) const
{
    M_Matrix<double> OO=ones<double>(k_u,k_u);
    M_Matrix<double> SS(k_u,k_u);
    M_Matrix<double> Qrun=Q0_M+Q1_M*agonist_concentration;
    try
    {
	SS=OO*inv(Qrun+OO);
    }
    catch (Markov_LA::SingularMatrix_error)   // revise this later
    {
	double t=1;
	M_Matrix<double> SSdif;
	OO=expm(Qrun*t);
	SS=expm(Qrun*(t*2));
	M_Matrix<double>* SS0=&OO;
	M_Matrix<double>* SS1=&SS;
	while (!(SS==OO))
	{
	    SS0=SS1;
	    t*=2;
	    (*SS1)=expm(Qrun*(t*2));
	}
	std::cout<<"\n t="<<t<<"  SS=\n"<<SS;
	std::cout<<"\n _Qrun="<<Qrun<<"\n";

	std::cout<<"\n _Qrun+OO are singular\n";
	assert(false);
    }
    M_Matrix<double> Peq_(ones<double>(1,k_u)*(1.0/k_u));
    Peq_=Peq_*SS;
    //std::cout<<"Peq before round to zero"<<Peq_;

    round_to_zero(Peq_);
    //std::cout<<"after"<<Peq_;
    //press_any_key_to_continue();
    return Peq_;
}

Markov_Transition_step Q_Markov_Model::get_Q_dt_no_avg(
	const Markov_IO::ABC_measure_point& xdt_A) const
{
    Markov_IO::x_dt xdt(xdt_A);
    Markov_Transition_rate Qx_v(k_u,false);
    Qx_v=Q_x(xdt.x(),false);
    Markov_Transition_step Qdt_v;
    Qdt_v=Markov_Transition_step(k_u,false, false,false);
    //std::cerr<<Qdt_v.P;

    std::vector<double> E00(k_u);
    for (std::size_t i=0; i<k_u; i++)
	E00[i]=std::exp(Qx_v.landa[i]*xdt.dt());

    for (std::size_t i=0; i<k_u; i++)
	for (std::size_t j=0; j<k_u; j++)
	{
	    for (std::size_t k1=0; k1<k_u; k1++)
		Qdt_v.P(i,j)+=Qx_v.V(i,k1)*Qx_v.W(k1,j)*E00[k1];
	    //std::cerr<<" auqi \n"<<Qdt_v.P(i,j);
	    //std::cerr<<Qdt_v.P;
	    if (std::abs(Qdt_v.P(i,j))<1e-10)
		Qdt_v.P(i,j)=0.0;
	};
    Qdt_v.gmean_i=g();
    return Qdt_v;
}

Markov_Transition_step& Q_Markov_Model::get_Q_dt_avg(const ABC_measure_point& xdt_A, Markov_Transition_step& Qdt) const
{
    x_dt xdt(xdt_A);
    Markov_Transition_rate Qx_v;
//    std::cerr<<"get_Q_dt_avg 1";
    Qx_v=Q_x(xdt.x(),true);
//    std::cerr<<Qx_v<<" 2";
    std::vector<double> Wg_E0(k_u);
    Markov_LA::ToleranceComparison<double> tol;

    for (std::size_t k0=0; k0<k_u; k0++)
    {
	double rladt=Qx_v.landa[k0]*xdt.dt();
	if (tol.isEqual(rladt*rladt,0.0))
	    Wg_E0[k0]=Qx_v.Wg[k0];
	else
	    Wg_E0[k0]=Qx_v.Wg[k0]*(exp(rladt)-1.0)/rladt;
    };
    Qdt.gmean_i=zeros<double>(k_u,1);
    for (std::size_t k0=0; k0<k_u; k0++)
    {
	for (std::size_t j=0; j<k_u; j++)
	    Qdt.gmean_i[k0]+=Qx_v.V(k0,j)*Wg_E0[j];
    }
    //std::cerr<<"\n gmean \n"<<E0<<Qdt.gmean;

    //build E2
    M_Matrix<double> WgV_Wg_E2(k_u,k_u);
    for (std::size_t k0=0; k0<k_u; k0++)
    {
	double rladt=Qx_v.landa[k0]*xdt.dt();
	if (tol.isEqual(rladt*rladt,0.0))
	{
	    for (std::size_t k2=0; k2<k_u; k2++)
	    {
		double rla2dt=Qx_v.landa[k2]*xdt.dt();
		if (tol.isEqual(rla2dt*rla2dt,0.0))
		    WgV_Wg_E2(k0,k2)=Qx_v.WgV(k0,k2)*
				     Qx_v.Wg[k2]*0.5;
		else
		    WgV_Wg_E2(k0,k2)=Qx_v.WgV(k0,k2)*Qx_v.Wg[k2]*
				     (exp(rla2dt)-rla2dt-1.0)/rla2dt/rla2dt;
	    }
	}
	else
	{
	    for (std::size_t k2=0; k2<k_u; k2++)
	    {
		double rla2dt=Qx_v.landa[k2]*xdt.dt();
		if (tol.isEqual(rla2dt*rla2dt,0.0))
		{
		    WgV_Wg_E2(k0,k2)=Qx_v.WgV(k0,k2)*Qx_v.Wg[k2]*
				     (exp(rladt)-rladt-1.0)/rladt/rladt;
		}
		else if (tol.isEqual((rla2dt-rladt)*(rla2dt-rladt),0.0))   //comparing squared difference
		{
		    WgV_Wg_E2(k0,k2)=Qx_v.WgV(k0,k2)*Qx_v.Wg[k2]*
				     (1.0-exp(rladt)*(1.0-rladt))/rladt/rladt;
		}
		else
		{
		    WgV_Wg_E2(k0,k2)=Qx_v.WgV(k0,k2)*Qx_v.Wg[k2]*
				     (1.0/rladt/rla2dt+
				      exp(rla2dt)/rla2dt/(rla2dt-rladt)+
				      exp(rladt)/rladt/(rladt-rla2dt));
		}
	    }
	}
    }
    // vmean(i)=A(k,i,j) g(j) A(k2,j,j2) g(j2) E(k,k)
    // =V(i,k) W(k,j) g(j) V(j,k2) W(k2,j2) g(j2) E(k,k2)
    //         ___________________ ______________
    //         WgV(k,k2)           Wg(k2)
    //___________________________________________________

    // G_(i)=V(i,n1), W(n1,k)g(k) V(k,n2) W(n2,j)       E(n1,n2)
    //                ___________________ ______________
    //                WgV(n1,n2)          W(n2)
    //___________________________________________________

    Qdt.gsqr_i=zeros<double>(k_u,1);

    for (std::size_t i=0; i<k_u; i++)
    {
	for (std::size_t k0=0; k0<k_u; k0++)
	    for (std::size_t k2=0; k2<k_u; k2++)
		Qdt.gsqr_i[i]+=2*Qx_v.V(i,k0)*WgV_Wg_E2(k0,k2);

    }

    Qdt.gvar_i=M_Matrix<double>(k_u,1);
    for (std::size_t i=0; i<k_u; i++)
	Qdt.gvar_i[i]=Qdt.gsqr_i[i]-Qdt.gmean_i[i]*Qdt.gmean_i[i];

    return Qdt;
}

Markov_Transition_step& Q_Markov_Model::get_Q_dt_avg_var(const ABC_measure_point& xdt_A, Markov_Transition_step& Qdt) const
{
    x_dt xdt(xdt_A);
    // build EE0
    const Markov_Transition_rate Qx=Q_x(xdt.x(),true);
    // build EE0
    M_Matrix<double> E2(k_u,k_u);
    Markov_LA::ToleranceComparison<double> tol;
    for (std::size_t k0=0; k0<k_u; k0++)
    {
	double rladt=Qx.landa[k0]*xdt.dt();
	for (std::size_t k2=0; k2<k_u; k2++)
	{
	    double rladt2=Qx.landa[k2]*xdt.dt();
	    if (tol.isEqual((rladt-rladt2)*(rladt-rladt2),0.0))
		E2(k0,k2)=exp(rladt2);
	    else
		E2(k0,k2)=(exp(rladt)-exp(rladt2))/(rladt-rladt2);
	};
    };
    //std::cerr<<"\nEE0\n"<<EE0;
    Qdt.gtotal_ij=zeros<double>(k_u,k_u);
    Qdt.gtotal_ij=Qx.V*elemMult(Qx.WgV,E2)*Qx.W;

    /*for (std::size_t i=0; i<k_u; i++)
	for (std::size_t j=0; j<k_u; j++)
	    for (std::size_t n1=0; n1<k_u; n1++)
		for (std::size_t n2=0; n2<k_u; n2++)
		    Qdt.G_(i,j)+=2.0*Qx.V(i,n1)*Qx.WgV(n1,n2)*
				 Qx.W(n2,j)*EE0(n1,n2);
    */
    return Qdt;
}


Markov_Transition_step& Q_Markov_Model::get_Q_dt_two_anchor(const ABC_measure_point& xdt_A, Markov_Transition_step& Qdt) const
{
    x_dt xdt(xdt_A);
    // build EE0
    const Markov_Transition_rate Qx=Q_x(xdt.x(),true);
    // build EE0

    M_Matrix<double> WgV_E3=zeros<double>(k_u,k_u);
    Markov_LA::ToleranceComparison<double> tol;
    for (std::size_t n1=0; n1<k_u; n1++)
    {
	double x1=Qx.landa[n1]*xdt.dt();
	double expx1=exp(x1);
	for (std::size_t n3=0; n3<k_u; n3++)
	{
	    double x3=Qx.landa[n3]*xdt.dt();
	    if (tol.isEqual(x1,x3))
	    {
		for (std::size_t n2=0; n2<k_u; n2++)
		{
		    double x2=Qx.landa[n2]*xdt.dt();
		    if (tol.isEqual(x2,x1))
		    {
			WgV_E3(n1,n3)+=Qx.WgV(n1,n2)*Qx.WgV(n2,n3)*expx1/2;
		    }
		    else
		    {
			double expx2=exp(x2);
			WgV_E3(n1,n3)+=Qx.WgV(n1,n2)*Qx.WgV(n2,n3)*
				       (expx2+expx1*(-x2+x1-1))/(x1-x2)/(x1-x2);
		    };
		}
	    }
	    else
	    {
		double expx3=exp(x3);
		for (std::size_t n2=0; n2<k_u; n2++)
		{
		    double x2=Qx.landa[n2]*xdt.dt();
		    if (tol.isEqual(x2,x1))
		    {
			WgV_E3(n1,n3)+=Qx.WgV(n1,n2)*Qx.WgV(n2,n3)*
				       (expx3+expx1*(-x3+x1-1))/(x1-x3)/(x1-x3);
		    }
		    else if (tol.isEqual(x2,x3))
		    {
			WgV_E3(n1,n3)+=Qx.WgV(n1,n2)*Qx.WgV(n2,n3)*
				       (expx1+expx3*(x3-x1-1))/(x1-x3)/(x1-x3);
		    }
		    else
		    {
			double expx2=exp(x2);
			WgV_E3(n1,n3)+=Qx.WgV(n1,n2)*Qx.WgV(n2,n3)*
				       (expx3*(x1-x2)+expx1*(x2-x3)+
					expx2*(x3-x1))/((x1-x2)*(x1-x3)*(x2-x3));

		    };
		};
	    };
	};
    };
    //  std::cerr<<"WgV_E3"<<WgV_E3;
    Qdt.gtotal_sqr_ij=(Qx.V*(WgV_E3*2.0)*Qx.W);

    Qdt.gmean_ij=M_Matrix<double>(k_u,k_u);
    Qdt.gvar_ij=M_Matrix<double>(k_u,k_u);
    for (std::size_t i=0; i<k_u; i++)
	for (std::size_t j=0; j<k_u; j++)
	    if (Qdt.P(i,j)>1e-9)
	    {
		Qdt.gmean_ij(i,j)=Qdt.gtotal_ij(i,j)/Qdt.P(i,j);
		Qdt.gvar_ij(i,j)=Qdt.gtotal_sqr_ij(i,j)/Qdt.P(i,j)-Qdt.gmean_ij(i,j)*Qdt.gmean_ij(i,j);
	    }
	    else
	    {
		Qdt.gmean_ij(i,j)=0;
		Qdt.gvar_ij(i,j)=0;
	    }

    M_Matrix<double> u=ones<double>(k_u,1);
    Qdt.gtotal_var_ij=elemMult(Qdt.gvar_ij,Qdt.P);
    Qdt.gtotal_var_i=Qdt.gtotal_var_ij*u;

    // std::cerr<<Qdt;
    // press_any_key_to_continue();
    return Qdt;
}


/**___________________________________________________________________________________________________________

				    Q_Markov_Model::Q_Model_step Implementation

---------------______________________________________________________________________________-----------------*/

/**
  Regular function that computes the Transition probability for a given
  interval of measurements.
  This function is used  to update the knowledge of the distribution of
  states.
  @param xdt is a valid measurment step that contains the evolution of the
  agonist concentration during a given interval of time.
  @param likelihood depending on the bayesian likelihood algorithm different aspects
  of the transition probability are calculated
  @returns an valued object with all the necessary information to perform
    different bayesian analysis during the time interval.
 */
//Markov_Transition_step  Q_Markov_Model::Q_step (
//	const Markov_IO::ABC_measure_step& xdt ,
//	const Markov_Bay::ABC_Markov_Likelihood_step& likelihood)const{};


Markov_Transition_step Q_Markov_Model::Q_step (const ABC_measure_step& xdt_A, bool is_averaging, bool two_anchor)const
{
    bool varying_x=(xdt_A.num_steps()>1);
    //    std::cerr<<" Q_step: ";
    Markov_Transition_step Qdt=Q_dt(xdt_A.sub_step(0),is_averaging,varying_x, two_anchor);

//    std::cerr<<"Q_dt_buff_avg_varx;"<<Q_dt_buff_avg_varx;
//    std::cerr<<"Q_dt_buff_avg;"<<Q_dt_buff_avg;
//    std::cerr<<"Q_dt_buff_not_avg;"<<Q_dt_buff_not_avg;

//    std::cerr<<"Qe_x_buff_avg;"<<Q_x_buff_avg;
//    std::cerr<<"Q_x_buff_not_avg;"<<Q_x_buff_not_avg;

    if (varying_x)
    {
	if (is_averaging)
	{
	    if(two_anchor)
	    {
		double dt=xdt_A.sub_step(0).dt();
		M_Matrix<double> PPn=Qdt.P;
		M_Matrix<double> PG_n=Qdt.gtotal_ij*dt;
		M_Matrix<double> PGG_n=Qdt.gtotal_sqr_ij*(dt*dt);
//            std::cout<<"\n Qdt.GG_M \n"<<Qdt.GG_M;

		//          std::cout<<"\n gmean_M \n"<<gmean_M;

//           std::cout<<"\n PGGn \n"<<PGGn;

		double dtrun=dt;
		for (std::size_t i=1; i<xdt_A.num_steps(); ++i)
		{
		    dt=xdt_A.sub_step(i).dt();
		    Qdt=Q_dt(xdt_A.sub_step(i),is_averaging,varying_x,two_anchor);
		    PGG_n=(PGG_n*Qdt.P) +(PG_n*Qdt.gtotal_ij)*dt+ (PPn*Qdt.gtotal_sqr_ij)*(dt*dt);
		    PG_n= (PG_n*Qdt.P) + (PPn*Qdt.gtotal_ij)*dt;
		    PPn=PPn*Qdt.P;
		    dtrun+=dt;
		};

		Qdt.P=PPn;

		Qdt.gtotal_sqr_ij=PGG_n/(dtrun*dtrun*0.5);
		Qdt.gtotal_ij=PG_n/dtrun;
		M_Matrix<double> u=ones<double>(k_u,1);

		Qdt.gmean_i=Qdt.gtotal_ij*u;
		Qdt.gsqr_i=Qdt.gtotal_sqr_ij*u;
		Qdt.gvar_i=Qdt.gsqr_i-elemMult(Qdt.gmean_i,Qdt.gmean_i);;

		Qdt.gmean_ij=M_Matrix<double>(k_u,k_u);
		Qdt.gvar_ij=M_Matrix<double>(k_u,k_u);
		for (std::size_t i=0; i<k_u; i++)
		    for (std::size_t j=0; j<k_u; j++)
			if (Qdt.P(i,j)>1e-9)
			{
			    Qdt.gmean_ij(i,j)=Qdt.gtotal_ij(i,j)/Qdt.P(i,j);
			    Qdt.gvar_ij(i,j)=Qdt.gtotal_sqr_ij(i,j)/Qdt.P(i,j)-Qdt.gmean_ij(i,j)*Qdt.gmean_ij(i,j);
			}
			else
			{
			    Qdt.gmean_ij(i,j)=0;
			    Qdt.gvar_ij(i,j)=0;
			}

		Qdt.gtotal_var_ij=elemMult(Qdt.gvar_ij,Qdt.P);
		Qdt.gtotal_var_i=Qdt.gtotal_var_ij*u;
	    }

	    else
	    {
		double dt=xdt_A.sub_step(0).dt();
		M_Matrix<double> PPn=Qdt.P;
		M_Matrix<double> PGn=Qdt.gmean_i*dt;
		M_Matrix<double> PG_n=Qdt.gtotal_ij*dt;
		M_Matrix<double> PGGn=Qdt.gsqr_i*(dt*dt);
//            std::cout<<"\n Qdt.GG_M \n"<<Qdt.GG_M;

		//          std::cout<<"\n gmean_M \n"<<gmean_M;

//           std::cout<<"\n PGGn \n"<<PGGn;

		double dtrun=dt;
		for (std::size_t i=1; i<xdt_A.num_steps(); ++i)
		{
		    dt=xdt_A.sub_step(i).dt();
		    Qdt=Q_dt(xdt_A.sub_step(i),is_averaging,varying_x);
//                std::cout<<"\n Qdt"<<Qdt;
		    PGn+=((PPn*Qdt.gmean_i)*dt);
		    PGGn+=((PPn*Qdt.gsqr_i)*(dt*dt) + (PG_n*Qdt.gmean_i)*dt);
		    PG_n= (PG_n*Qdt.P) + (PPn*Qdt.gtotal_ij)*dt;
		    PPn=PPn*Qdt.P;
		    dtrun+=dt;
		};
		Qdt.P=PPn;

		Qdt.gmean_i=PGn*(1.0/dtrun);
		PGGn*=(2.0/dtrun/dtrun);
		Qdt.gvar_i=PGGn-elemMult(Qdt.gmean_i,Qdt.gmean_i);
	    }
	}
	else
	{
	    M_Matrix<double> PPn=Qdt.P;
	    for (std::size_t i=1; i<xdt_A.num_steps(); ++i)
	    {
		Qdt=Q_dt(xdt_A.sub_step(i),is_averaging,varying_x);
		PPn=PPn*Qdt.P;
	    };
	    Qdt.P=PPn;
	};
    };
    return Qdt;
}

Markov_state Q_Markov_Model::start(double equilibrium_concentration,
				   std::size_t Nchannels,
				   Borrowed::MersenneTwister::MTRand& sto)const
{
    Markov_state M;

    M.N()=random_N_sample(this->Peq(equilibrium_concentration), Nchannels,sto);
    M.P()=Peq(equilibrium_concentration);
    M.ymean()=(M.N()*this->g())[0];
    return M;
}

Markov_state_ext Q_Markov_Model::start(double equilibrium_concentration,
				       std::size_t Nchannels,
				       Borrowed::MersenneTwister::MTRand& sto,
				       bool ext)const
{
    Markov_state_ext M(k_u);
    M.N=random_N_sample(this->Peq(equilibrium_concentration), Nchannels,sto);
    M.P=Peq(equilibrium_concentration);
    M.ymean=(M.N*this->g())[0];
    return M;
}

Markov_state& Q_Markov_Model::run(const ABC_measure_point& xdt,
				  Markov_state& N_run,
				  double time_step,
				  Borrowed::MersenneTwister::MTRand& sto
				  )const
{
    size_t n_steps=std::size_t(ceil(xdt.dt()/time_step));
    double ddt=xdt.dt()/n_steps;
    x_dt xddt(ddt,xdt.x());
    Markov_Transition_step Qddt=Q_dt(xddt,false,false);
    if (Qddt.P[0]==0)
    {
	//std::cout<<Qddt;
	//std::cout<<"xddt \n"<<xddt;
	Markov_Transition_step Qddt2=Q_dt(xddt,false,false);
	//press_any_key_to_continue();
	//std::cout<<Qddt2;
	//press_any_key_to_continue();
	//std::cout<<*this;
	//std::cout<<"Peq"<<Peq(0.0);
	//press_any_key_to_continue();
}
    double ysum=0;
    for (std::size_t i=0; i<n_steps; i++)
    {
	N_run.N()=random_P_on_N(Qddt,N_run.N(),sto);

	ysum+=(N_run.N()*g())[0];
	N_run.P()=N_run.P()*Qddt.P;
    }
    N_run.ymean()=ysum/n_steps;
    return N_run;
}

Markov_state& Q_Markov_Model::run(const ABC_measure_step& xdt,
				  Markov_state& N_run,
				  double time_step,
				  Borrowed::MersenneTwister::MTRand& sto)const
{
    double ysum=0;
    double tsum=0;
    for (std::size_t i=0; i<xdt.num_steps(); i++)
    {
	N_run=run(xdt.sub_step(i),N_run,time_step,sto);
	ysum+=N_run.ymean()*xdt.dt();
	tsum+=xdt.dt();
    }
    N_run.ymean()=ysum/tsum;
    return N_run;
}

Markov_state_ext& Q_Markov_Model::run(const ABC_measure_point& xdt,
				      Markov_state_ext& N_run,
				      double time_step,
				      Borrowed::MersenneTwister::MTRand& sto)const
{
    N_run.ymean=0.0;
    N_run.ysqr=0.0;
    N_run.N_mean=0.0;
    N_run.N_sqr=0.0;
    size_t n_steps=std::size_t(ceil(xdt.dt()/time_step));
    double ddt=xdt.dt()/n_steps;
    x_dt xddt(ddt,xdt.x());
    Markov_Transition_step Qddt=Q_dt(xddt,false,false);
    for (std::size_t i=0; i<n_steps; i++)
    {
	N_run.N=random_P_on_N(Qddt,N_run.N,sto);
	double y=(N_run.N*g())[0];
	N_run.N_mean+=N_run.N;
	N_run.N_sqr+=elemMult(N_run.N,N_run.N);
	N_run.ymean+=y;
	N_run.ysqr+=y*y;
	N_run.P=N_run.P*Qddt.P;
    }
    N_run.ymean=N_run.ymean/double(n_steps);
    N_run.ysqr=N_run.ysqr/double(n_steps);
    N_run.N_mean=N_run.N_mean/double(n_steps);
    N_run.N_sqr=N_run.N_sqr/double(n_steps);

    N_run.ystd=sqrt(N_run.ysqr-N_run.ymean*N_run.ymean);
    for (std::size_t i=0; i<k_u; i++)
    {
	N_run.N_std[i]=sqrt(N_run.N_sqr[i]-N_run.N_mean[i]*N_run.N_mean[i]);
    };
    return N_run;
}

Markov_state_ext& Q_Markov_Model::run(const ABC_measure_step& xdt,
				      Markov_state_ext& N_run,
				      double time_step,
				      Borrowed::MersenneTwister::MTRand& sto)const
{
    if (xdt.num_steps()>1)
    {
	double ysum=0;
	double tsum=0;
	double ysqrsum=0;
	M_Matrix<double> Nsum=zeros<double>(1,k_u);
	M_Matrix<double> Nsqrsum=zeros<double>(1,k_u);
	for (std::size_t i=0; i<xdt.num_steps(); i++)
	{
	    N_run=run(xdt.sub_step(i),N_run,time_step,sto);
	    ysum+=N_run.ymean*xdt.dt();
	    ysqrsum+=N_run.ysqr*xdt.dt();
	    Nsum+=N_run.N_mean*xdt.dt();
	    Nsqrsum+=N_run.N_sqr*xdt.dt();
	    tsum+=xdt.dt();
	}
	N_run.ymean=ysum/tsum;
	N_run.N_mean=Nsum/tsum;
	N_run.N_sqr=Nsqrsum/tsum;
	N_run.ysqr=ysqrsum/tsum;
	N_run.ystd=sqrt(N_run.ysqr-N_run.ymean*N_run.ymean);
	for (std::size_t i=0; i<k_u; i++)
	{
	    N_run.N_std[i]=sqrt((N_run.N_sqr[i]-N_run.N_mean[i]*N_run.N_mean[i]));
	};
    }
    else
    {
	N_run=run(xdt.sub_step(0),N_run,time_step,sto);
    };
    return N_run;
}


std::string Q_Markov_Model::gamma_Label()
{
    return  "unitary conductance";
}

//std::ostream& Q_Markov_Model::put(std::ostream&s) const
//{

//}

// Markov_Transition_step Q_Markov_Model::Q_dt(
//	const Markov_IO::ABC_measure_point& xdt,
//	const Markov_Bay::ABC_Markov_Likelihood_step& likelihood)const{}



//std::string Q_Markov_Model::DirName()const
//{
//    return dirName_;
//}
//std::string Q_Markov_Model::Author()const
//{
//    return author_;
//}
//std::string Q_Markov_Model::Date()const
//{
//    return date_;
//}
//std::string Q_Markov_Model::Id()const
//{
//    return id_;
//}

//std::string Q_Markov_Model::Extension()const
//{
//     return "experiment";
//}

//std::string Q_Markov_Model::FileName()const
//{
//    return Markov_IO::ABC_Saveable::FileName();
//}


ClassDescription Q_Markov_Model::GetDescription()const
{
    ClassDescription desc("Q_Markov_Model");

    desc.push_back("model_name_identifier",name_);
    desc.push_back("Q_matrix",Q_M);
    desc.push_back("conductance_vector",
		   g0_M);
    desc.push_back("agonist_vector",
		   a_M);
    desc.push_back("unitary_conductance",
		   gamma_d);

    return desc;


}

bool Q_Markov_Model::LoadFromDescription(
    const ClassDescription& classDes)
{
    if (classDes.ClassName()!="Q_Markov_Model")
	return false;


    std::string model_name_identifier=classDes["vector_of_traces"];

    M_Matrix<double> Q_matrix;
    if (!ToValue(classDes["Q_matrix"],Q_matrix))
	return false;


    M_Matrix<double> conductance_vector;
    if (!ToValue(classDes["conductance_vector"],conductance_vector))
	return false;

    M_Matrix<std::size_t> agonist_vector;
    if (!ToValue(classDes["agonist_vector"],agonist_vector))
	return false;

    double unitary_conductance;
    if (!ToValue(classDes["unitary_conductance"],unitary_conductance))
	return false;


    *this=Q_Markov_Model(model_name_identifier,
			 Q_matrix,
			 conductance_vector,
			 agonist_vector,
			 unitary_conductance);

    return true;
}



}
